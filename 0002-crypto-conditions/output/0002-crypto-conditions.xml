<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3280 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3280.xml">
<!ENTITY RFC4055 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC6920 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6920.xml">
<!ENTITY RFC8017 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8017.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-08 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-08.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="December" day="16"/>

    <area>security</area>
    
    

    <abstract>


<t>The crypto-conditions specification defines a set of encoding formats and data structures for <spanx style="strong">conditions</spanx> and <spanx style="strong">fulfillments</spanx>.  A condition uniquely identifies a logical "boolean circuit" constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that define the structure of the circuit and provide inputs to the logic gates allowing for the result of the circuit to be evaluated.</t>

<t>A fulfillment is validated by evaluating that the circuit output is TRUE but also that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different types of crypto-conditions each have different internal strutures and employ different cryptographic algorithms as primitives.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding of common cryptographic primitives with hardcoded parameters, e.g RSA and ED25519 signature or SHA256 hash digests. As such, simple types that use the same underlying scheme (e.g. SHA) with different parameters (e.g. 256 or 512 bits) are considered different crypto-condition types.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm to generate the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition generated using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. The compound crypto-condition will evaluate to TRUE or FALSE based on the output of the evaluation of the sub-crypto-conditions. In this way compound crypto-conditions are used to construct branches of a boolean circuit.</t>

<t>To validate a compound crypto-condition all sub-crypto-conditions are provided in the fulfillment so that the fingerprint of the compound condition can be generated. However, some of these sub-crypto-conditions may be sub-fulfillments and some may be sub-conditions, depending on the type and properties of the compound crypto-condition.</t>

<t>As an example, in the case of an m-of-n signature scheme, only m sub-fulfillments are needed to validate the compound signature, but the remaining n-m sub-conditions must still be provided to validate that the complete fulfillment matches the originally provided condition. This is an important feature for multi-party signing, when not all parties are ready to provide fulfillment yet all parties still desire fulfillment of the overall condition if enough counter-parties do provide fulfillment.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and Supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefore it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility. That said, it is important that implementations must inspect the ypes and subtypes of any crypto-conditions they encounter to ensure they do not pass on a condition they will not be able to verify at a later stage.</t>

<t>In many instances protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:</t>

<t><list style="numbers">
  <t>Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input</t>
  <t>The same public key can be used to validate multiple different signatures, each against a different message</t>
  <t>It is not possible to derive the signature from the public key</t>
</list></t>

<t>However, the scheme also has a number of features that make it unique such as:</t>

<t><list style="numbers">
  <t>It is possible to derive the same public key from any valid signature without the message</t>
  <t>It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.</t>
  <t>Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.</t>
  <t>A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>
</list></t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefore conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefore <spanx style="strong">cryptographically verifiable event notifications</spanx> that can be used to verify the event occurred but also that it matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefore the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide non-repudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, follows these steps:</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F however in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and calculate the hash digest of this data.</t>
  <t>Calculate the maximum cost of validating a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>.</t>

<section anchor="encoding-rules" title="Encoding Rules">

<t>Implementations of this specificiation MUST support encoding and decoding using Distinguished Encoding Rules (DER) as defined in <xref target="itu.X690.2015"></xref>. This is the canonical encoding format.</t>

<t>Alternative encodings may be used to represent top-level conditions and fulfillments but to ensure a determinisitic outcome in producing the condition fingerprint content, including any sub-conditions, MUST be DER encoded prior to hashing.</t>

<t>The excpetion is the PREIMAGE-SHA-256 condition where the fingerprint content is the raw preimage which is not encoded prior to hashing. This is to allow a PREIMAGE-SHA-256 crypto-condition to be used in systems where "hash-locks" are already in use.</t>

</section>
<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions differs based on their type. All types define at least a fingerprint and maxCost sub-field. Some types, such as the compound condition types, define additional sub-fields that are required to convey essential properties of the crypto-condition (such as the sub-types used by sub-conditions in the case of the compound types).</t>

<t>Each crypto-condition type has a type ID. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= CHOICE {
  preimageSha256Condition  [0] Simple256Condition,
  prefixSha256Condition    [1] Compound256Condition,
  thresholdSha256Condition [2] Compound256Condition,
  rsaSha256Condition       [3] Simple256Condition,
  ed25519Sha256Condition   [4] Simple256Condition
}

Simple256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295)
}

Compound256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519Sha256   (4)
}
]]></artwork></figure>

<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions <spanx style="strong">of the same type</spanx>.</t>

<t>Implementations which index conditions MUST use the complete encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This means the fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint, which may have different lengths, therefore the field is encoded as a variable length string.</t>

</section>
<section anchor="cost" title="Cost">

<t>For each type, a cost function is defined which produces a determinsitic cost value based on the properties of the condition.</t>

<t>The cost functions are designed to produce a number that will increase rapidly if the structure and properties of a crypto-condition are such that they increase the resource requirements of a system that must validate the fulfillment.</t>

<t>The constants used in the cost functions are selected in order to provide some consistency across types for the cost value and the expected "real cost" of validation. This is not an exact science given that some validations will require signature verification (such as RSA and ED25519) and others will simply require hashing and storage of large values therefore the cost functions are roughly configured (through selection of constants) to be the number of bytes that would need to be processed by the SHA-256 hash digest algorithm to produce the equivalent amount of work.</t>

<t>The goal is to produce an indicative number that implementations can use to protect themselves from attacks involving crypto-conditions that would require massive resources to validate (denial of service type attacks).</t>

<t>Since dynamic heuristic measures can't be used to acheive this a deterministic value is required that can be produced consistently by any implementation, therefore for each crypto-condition type, an algorithm is provided for consistently calculating the cost.</t>

<t>Implementations MUST determine a safe cost ceiling based on the expected cost value of crypto-conditions they will need to process. When a crypto-condition is submitted to an implementation, the implementation MUST verify that it will be able to process a fulfillment with the given cost (i.e. the cost is lower than the allowed ceiling) and reject it if not.</t>

<t>Cost function constants have been rounded to numbers that have an efficient base-2 representation to facilitate efficient arithmetic operations.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>Subtypes is a bitmap that indicates the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of all sub-crypto-conditions, recursively.</t>

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available to be analysed yet. Therefore, all compound conditions set the bits in this bitmap that correspond to the set of types and subtypes of all sub-crypto-conditions.</t>

<t>The field is encoded as a variable length BIT STRING, as defined in ASN.1 to accommodate new types that may be defined.</t>

<t>Each bit in the bitmap represents a type from the list of known types in the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>The presence of one or more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>For example, a compound condition that contains an ED25519-SHA-256 crypto-condition as a sub-crypto-condition will set the bit at position 4.</t>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>The ASN.1 definition for fulfillments is defined as follows:</t>

<figure><artwork><![CDATA[
Fulfillment ::= SET OF Subfulfillment

Subfulfillment ::= CHOICE {
  preimageSubfulfillment   [0] PreimageSubfulfillment,
  prefixSubfulfillment     [1] PrefixSubfulfillment,
  thresholdSubfulfillment  [2] ThresholdSubfulfillment,
  rsaSha256Subfulfillment  [3] RsaSha256Subfulfillment,
  ed25519Subfulfillment    [4] Ed25519Subfulfillment
}

PreimageSubfulfillment ::= SEQUENCE {
  preimage OCTET STRING
}

PrefixSubfulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}

ThresholdSubfulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subconditions SEQUENCE OF Condition
}

RsaSha256Subfulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

Ed25519Subfulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}

-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
  modulus INTEGER,  -- n
  publicExponent INTEGER -- e
}
]]></artwork></figure>

</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. While support for additional crypto-condition types may be added in the future and will be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>, no other types are supported by this specification.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-maxcost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> preimage, plus the constant 32. The constant is added to ensure that even a zero length fulfillment reflects some processing cost. This prevents a large number of very small PREIMAGE-SHA-256 sub-fulfillments being used to construct a fulfillment that has a low calculated cost but a large real cost to process.</t>

<figure><artwork><![CDATA[
cost = preimage + 32
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
-- The PREIMAGE-SHA-256 condition fingerprint content is not DER encoded
-- The fingerprint content is the preimage

-- Fulfillment 
PreimageSubfulfillment ::= SEQUENCE {
  preimage OCTET STRING
}
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the <spanx style="strong">unencoded</spanx> preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment simply contains the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by its sub-crypto-condition as it is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to narrow the scope of other crypto-conditions that are used inside the prefix crypto-condition as a sub-crypto-condition.</t>

<t>Because a condition is the fingerprint of a public key, by creating a prefix crypto-condition that wraps another crypto-condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple crypto-conditions, each with a different prefix, and therefore generate a unique condition and fulfillment each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-cost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> prefix plus the cost of the sub-condition multiplied by 1.25.</t>

<figure><artwork><![CDATA[
cost = prefix.length + ( subcondition.cost * 1.25 )
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
PrefixSha256FingerprintContents ::= PrefixSubfulfillment

-- Fulfillment 
PrefixSubfulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which are identical 
to contents of the PrefixSubfulfillment.</t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation of the sub-fulfillment.</t>
  <t hangText='subcondition'>
  is the condition derived from the sub-fulfillment of this parent fulfillment.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>The fulfillment (f) that satisfies F.subcondition is valid, where the message used for validation of f is M prefixed by F.prefix AND</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by any of its sub-crypto-conditions as it is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-cost" title="Cost">

<t>The cost is the sum of the F.threshold largest cost values of all sub-conditions, added to 32 times the difference between the total sub-conditions and F.threshold.</t>

<figure><artwork><![CDATA[
cost = (sum of largest F.threshold subcondition.cost values) + 32 * (F.subconditions.count - F.threshold)
]]></artwork></figure>

<t>For example, if a threshold crypto-condition contains 5 sub-conditions with costs of 64, 64, 82, 84 and 84 and has a threshold of 3, the cost is equal to the sum of the largest three sub-condition costs (82 + 84 + 84 = 250) plus 32 times the number of remaining conditions (32 * (5 - 3) = 64): 314</t>

<t>Implementations MUST accept THRESHOLD-SHA-256 fulfillments with more sub-fulfillments provided that satisfy the sub-conditions than required by the threshold. In a complex multi-layer fulfillment, sub-fulfillments may be provided that satisfy sub-conditions within multiple compound conditions therefor it is impossible to avoid providing more sub-fulfillments than are required in some cases.</t>

<t>Implementations SHOULD only validate as many sub-fulfillments as are required to meet the threshold, favouring those with lower cost where possible.</t>

</section>
<section anchor="threshold-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
ThresholdSubfulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subconditions SEQUENCE OF Condition
}

-- Fulfillment 
ThresholdSha256FingerprintContents ::= ThresholdSubfulfillment    
]]></artwork></figure>

</section>
<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which are identical 
to the contents of the ThresholdSubfulfillment.</t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 65535. In order to fulfill a threshold condition, the count of the sub-conditions that are satisfied by one of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions, F.threshold of which MUST be satisfied by provided fulfillments. The list of DER encoded sub-conditions is sorted first based on encoded length, shortest first and then elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>The number of F.subconditions, satisfied by provided fulfillments, is equal to or greater than F.threshold.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256 digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC8017"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefore, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC8017"></xref>. The algorithm parameters to use, as defined in <xref target="RFC4055"></xref> are:</t>

<figure><artwork><![CDATA[
pkcs-1 OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }

id-sha256 OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }

sha256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-sha256,
  parameters nullParameters  
}
                          
id-mgf1 OBJECT IDENTIFIER  ::=  { pkcs-1 8 }                          
                          
mgf1SHA256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-mgf1,
  parameters sha256Identifier 
}

rSASSA-PSS-SHA256-Params RSASSA-PSS-params ::=  {
  hashAlgorithm sha256Identifier,
  maskGenAlgorithm mgf1SHA256Identifier,
  saltLength 20,
  trailerField 1
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-cost" title="Cost">

<t>The cost is the square of RSA key modulus size (in bits) divided by the constant 64.</t>

<figure><artwork><![CDATA[
cost = ( (modulus size in bits) ^ 2 ) / 64 
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
RSASha256FingerprintContents ::= RSAPublicKey

-- Fulfillment 
RsaSha256Subfulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
      modulus INTEGER,  -- n
      publicExponent INTEGER -- e
}
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the DER encoded RSA Public Key encoded per the rules in <xref target="RFC8017"></xref>{#8017}.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='publicKey'>
  Implementations MUST use moduli greater than 128 bytes (1017 bits) and smaller than or equal to 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref>. OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref>.</t>
  <t>Implementations MUST use the value 65537 for the publicExponent e as recommended in <xref target="RFC4871"></xref>. Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref>. This constraint is not reflected in the ASN.1 definition as this would affect the encoding but MUST be enforced by implementations.</t>
  <t hangText='signature'>
  is an octet string representing the RSA signature.</t>
  <t>Implementations MUST verify that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref>. In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the RSA public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="ed25519-sha-256-condition-type" title="ED25519-SHA256">
<t>ED25519-SHA-256 is assigned the type ID 4. It relies on the SHA-256 and SHA-512 digest algorithms and the ED25519 signature scheme.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function for this signature scheme.</t>

<section anchor="ed25519-sha-256-condition-type-cost" title="Cost">

<t>The public key and signature are a fixed size therefore the cost for an ED25519 crypto-condition is fixed at 131072.</t>

<figure><artwork><![CDATA[
cost = 131072
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
Ed25519Subfulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}

-- Fulfillment 
Ed25519Sha256FingerprintContents ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32))
}
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519-SHA-256 condition is the SHA-256 digest of the DER encoded Ed25519 public key. While the public key is already very small and constant size, we hash it for consistency with the other types.</t>

</section>
<section anchor="ed25519-sha-256-condition-type-fulfillment" title="Fulfillment">

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example" title="Example">

<t>TODO</t>

</section>
</section>
</section>
<section anchor="uri-encoding-rules" title="URI Encoding Rules">

<t>Conditions can be encoded as URIs per the rules defined in the Named Information specification, <xref target="RFC6920"></xref>. There are no URI encoding rules for fulfillments.</t>

<t>Applications that require a string encoding for fulfillments MUST use an appropriate string encoding of the DER encoded binary representation of the fulfillment. No string encoding is defined in this specification. For consistency with the URI encoding of conditions, BASE64URL is recommended as described in <xref target="RFC4648"></xref>, Section 5.</t>

<t>The URI encoding is only used to encode top-level conditions and never for sub-conditions. The binary encoding is considered the canonical encoding.</t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are represented as URIs using the rules defined in <xref target="RFC6920"></xref> where the object being hashed is the DER encoded fingerprint content of the condition as described for the specific condition type.</t>

<t>While <xref target="RFC6920"></xref> allows for truncated hashes, implementations using the Named Information URI schemes for crypto-conditions MUST only use untruncated SHA-256 hashes (Hash Name: sha-256, ID: 1 from the "Named Information Hash Algorithm Registry" defined in <xref target="RFC6920"></xref>).</t>

</section>
<section anchor="new-uri-parameter-definitions" title="New URI Parameter Definitions">

<t><xref target="RFC6920"></xref> established the IANA registry of "Named Information URI Parameter Definitions". This specification defines three new definitions that are added to that registry and passed in URI encoded conditions as query string parameters.</t>

<section anchor="parameter-type" title="Parameter: type">

<t>The type parameter indicates the type of condition that is represented by the URI. The value MUST be one of the names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

</section>
<section anchor="parameter-cost" title="Parameter: cost">

<t>The cost parameter is the cost of the condition that is represented by the URI.</t>

</section>
<section anchor="parameter-subtypes" title="Parameter: subtypes">

<t>The subtypes parameter indicates the types of conditions that are subtypes of the condition represented by the URI. The value MUST be a comma seperated list of names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

</section>
</section>
</section>
<section anchor="example-condition" title="Example Condition">

<t>An example condition (PREIMAGE-SHA-256):</t>

<figure><artwork><![CDATA[
0x00000000 A0 25 80 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 81 .%.....e...S.-..
0x00000010 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 00 H..].-K...w(J...
0x00000020 12 6D 90 69 81 01 0C                            .m.i...

ni:///sha-256;f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk?type=preimage-sha-256&cost=44
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>scheme</c>
      <c><spanx style="verb">ni://</spanx></c>
      <c>The named information scheme.</c>
      <c>hash function name</c>
      <c><spanx style="verb">sha-256</spanx></c>
      <c>The fingerprint is hashed with the SHA-256 digest function</c>
      <c>fingerprint</c>
      <c><spanx style="verb">f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk</spanx></c>
      <c>The fingerprint for this condition.</c>
      <c>type</c>
      <c><spanx style="verb">preimage-sha-256</spanx></c>
      <c>This is a [PREIMAGE-SHA-256][] condition.</c>
      <c>cost</c>
      <c><spanx style="verb">44</spanx></c>
      <c>The fulfillment payload is 12 bytes long, therefor the cost is (32 + 12): 44.</c>
</texttable>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3280;
&RFC4055;
&RFC4648;
&RFC6920;
&RFC8017;
&I-D.draft-irtf-cfrg-eddsa-08;
<reference anchor="itu.X680.2015" target="http://handle.itu.int/11.1002/1000/12479">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X690.2015" target="http://handle.itu.int/11.1002/1000/12483">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This specification has a normative dependency on a number of other specifications with extensive security considerations therefore the consideratons defined for SHA-256 hashing and RSA signatures in <xref target="RFC8017"></xref> and <xref target="RFC4055"></xref> and for ED25519 signatures in <xref target="I-D.irtf-cfrg-eddsa"></xref> must be considered.</t>

<t>The cost and subtypes values of conditions are provided to allow implementations to evaluate their ability to validate a fulfillment for the given condition later.</t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --></t>

<t>For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--
]]></artwork></figure>

<t>Crypto-Conditions DEFINITIONS EXPLICIT TAGS ::= BEGIN</t>

<figure><artwork><![CDATA[
-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
  modulus INTEGER,  -- n
  publicExponent INTEGER -- e
}

-- CORE STRUCTURES

Crypto-Condition ::= Condition
Crypto-Fulfillment ::= Fulfillment

-- Conditions

Condition ::= CHOICE {
  preimageSha256Condition     [0] Simple256Condition,
  prefixSha256Condition       [1] Compound256Condition,
  thresholdSha256Condition    [2] Compound256Condition,
  rsaSha256Condition          [3] Simple256Condition,
  ed25519Sha256Condition      [4] Simple256Condition
}

Simple256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxCost INTEGER (0..4294967295)
}

Compound256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxCost INTEGER (0..4294967295),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519Sha256   (4)
}

-- Fulfillments

Fulfillment ::= SET OF Subfulfillment

Subfulfillment ::= CHOICE {
  preimageSubfulfillment   [0] PreimageSubfulfillment,
  prefixSubfulfillment     [1] PrefixSubfulfillment,
  thresholdSubfulfillment  [2] ThresholdSubfulfillment,
  rsaSha256Subfulfillment  [3] RsaSha256Subfulfillment,
  ed25519Subfulfillment    [4] Ed25519Subfulfillment
}

PreimageSubfulfillment ::= SEQUENCE {
  preimage OCTET STRING
}

PrefixSubfulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}

ThresholdSubfulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subconditions SEQUENCE OF Condition
}

RsaSha256Subfulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

Ed25519Subfulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}

-- Fingerprint Content

-- The PreimageSha256 fingerprint is the SHA256 hash of the raw preimage

PrefixSha256FingerprintContents ::= PrefixSubfulfillment

ThresholdSha256FingerprintContents ::= ThresholdSubfulfillment    

RsaSha256FingerprintContents ::= RSAPublicKey

Ed25519Sha256FingerprintContents ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32))
}
]]></artwork></figure>

<t>END</t>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>


  </back>

<!-- ##markdown-source:
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
i0pu3ZuUM/nNZn2bv82vG/8XVz4WYy+6AAA=

-->

</rfc>

