<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3280 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3280.xml">
<!ENTITY RFC4055 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY RFC6920 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6920.xml">
<!ENTITY RFC8017 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8017.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-08 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-08.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="December" day="17"/>

    <area>security</area>
    
    

    <abstract>


<t>The crypto-conditions specification defines a set of encoding formats and data structures for <spanx style="strong">conditions</spanx> and <spanx style="strong">fulfillments</spanx>.  A condition uniquely identifies a logical "boolean circuit" constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that define the structure of the circuit and provide inputs to the logic gates allowing for the result of the circuit to be evaluated.</t>

<t>A fulfillment is validated by evaluating that the circuit output is TRUE but also that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different types of crypto-conditions each have different internal strutures and employ different cryptographic algorithms as primitives.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding of common cryptographic primitives with hardcoded parameters, e.g RSA and ED25519 signature or SHA256 hash digests. As such, simple types that use the same underlying scheme (e.g. SHA) with different parameters (e.g. 256 or 512 bits) are considered different crypto-condition types.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm to generate the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition generated using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. The compound crypto-condition will evaluate to TRUE or FALSE based on the output of the evaluation of the sub-crypto-conditions. In this way compound crypto-conditions are used to construct branches of a boolean circuit.</t>

<t>To validate a compound crypto-condition all sub-crypto-conditions are provided in the fulfillment so that the fingerprint of the compound condition can be generated. However, some of these sub-crypto-conditions may be sub-fulfillments and some may be sub-conditions, depending on the type and properties of the compound crypto-condition.</t>

<t>As an example, in the case of an m-of-n signature scheme, only m sub-fulfillments are needed to validate the compound signature, but the remaining n-m sub-conditions must still be provided to validate that the complete fulfillment matches the originally provided condition. This is an important feature for multi-party signing, when not all parties are ready to provide fulfillment yet all parties still desire fulfillment of the overall condition if enough counter-parties do provide fulfillment.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and Supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefore it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility. That said, it is important that implementations must inspect the ypes and subtypes of any crypto-conditions they encounter to ensure they do not pass on a condition they will not be able to verify at a later stage.</t>

<t>In many instances protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:</t>

<t><list style="numbers">
  <t>Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input</t>
  <t>The same public key can be used to validate multiple different signatures, each against a different message</t>
  <t>It is not possible to derive the signature from the public key</t>
</list></t>

<t>However, the scheme also has a number of features that make it unique such as:</t>

<t><list style="numbers">
  <t>It is possible to derive the same public key from any valid signature without the message</t>
  <t>It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.</t>
  <t>Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.</t>
  <t>A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>
</list></t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefore conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefore <spanx style="strong">cryptographically verifiable event notifications</spanx> that can be used to verify the event occurred but also that it matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefore the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide non-repudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, follows these steps:</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F however in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and calculate the hash digest of this data.</t>
  <t>Calculate the maximum cost of validating a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>.</t>

<section anchor="encoding-rules" title="Encoding Rules">

<t>Implementations of this specificiation MUST support encoding and decoding using Distinguished Encoding Rules (DER) as defined in <xref target="itu.X690.2015"></xref>. This is the canonical encoding format.</t>

<t>Alternative encodings may be used to represent top-level conditions and fulfillments but to ensure a determinisitic outcome in producing the condition fingerprint content, any sub-conditions MUST be DER encoded prior to hashing.</t>

<t>The excpetion is the PREIMAGE-SHA-256 condition where the fingerprint content is the raw preimage which is not encoded prior to hashing. This is to allow a PREIMAGE-SHA-256 crypto-condition to be used in systems where "hash-locks" are already in use.</t>

</section>
<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions differs based on their type. All types define at least a fingerprint and maxCost sub-field. Some types, such as the compound condition types, define additional sub-fields that are required to convey essential properties of the crypto-condition (such as the sub-types used by sub-conditions in the case of the compound types).</t>

<t>Each crypto-condition type has a type ID. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= CHOICE {
  preimageSha256Condition  [0] Simple256Condition,
  prefixSha256Condition    [1] Compound256Condition,
  thresholdSha256Condition [2] Compound256Condition,
  rsaSha256Condition       [3] Simple256Condition,
  ed25519Sha256Condition   [4] Simple256Condition
}

Simple256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295)
}

Compound256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519Sha256   (4)
}
]]></artwork></figure>

<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions <spanx style="strong">of the same type</spanx>.</t>

<t>Implementations which index conditions MUST use the complete encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This means the fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint, which may have different lengths, therefore the field is encoded as a variable length string.</t>

</section>
<section anchor="cost" title="Cost">

<t>For each type, a cost function is defined which produces a determinsitic cost value based on the properties of the condition.</t>

<t>The cost functions are designed to produce a number that will increase rapidly if the structure and properties of a crypto-condition are such that they increase the resource requirements of a system that must validate the fulfillment.</t>

<t>The constants used in the cost functions are selected in order to provide some consistency across types for the cost value and the expected "real cost" of validation. This is not an exact science given that some validations will require signature verification (such as RSA and ED25519) and others will simply require hashing and storage of large values therefore the cost functions are roughly configured (through selection of constants) to be the number of bytes that would need to be processed by the SHA-256 hash digest algorithm to produce the equivalent amount of work.</t>

<t>The goal is to produce an indicative number that implementations can use to protect themselves from attacks involving crypto-conditions that would require massive resources to validate (denial of service type attacks).</t>

<t>Since dynamic heuristic measures can't be used to acheive this a deterministic value is required that can be produced consistently by any implementation, therefore for each crypto-condition type, an algorithm is provided for consistently calculating the cost.</t>

<t>Implementations MUST determine a safe cost ceiling based on the expected cost value of crypto-conditions they will need to process. When a crypto-condition is submitted to an implementation, the implementation MUST verify that it will be able to process a fulfillment with the given cost (i.e. the cost is lower than the allowed ceiling) and reject it if not.</t>

<t>Cost function constants have been rounded to numbers that have an efficient base-2 representation to facilitate efficient arithmetic operations.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>Subtypes is a bitmap that indicates the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of all sub-crypto-conditions, recursively.</t>

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available to be analysed yet. Therefore, all compound conditions set the bits in this bitmap that correspond to the set of types and subtypes of all sub-crypto-conditions.</t>

<t>The field is encoded as a variable length BIT STRING, as defined in ASN.1 to accommodate new types that may be defined.</t>

<t>Each bit in the bitmap represents a type from the list of known types in the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>The presence of one or more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>For example, a compound condition that contains an ED25519-SHA-256 crypto-condition as a sub-crypto-condition will set the bit at position 4.</t>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>The ASN.1 definition for fulfillments is defined as follows:</t>

<figure><artwork><![CDATA[
    --FULFILLMENTS

Fulfillment ::= SEQUENCE OF Subfulfillment

Subfulfillment ::= CHOICE {
  unfulfilledSubcondition  [0] Condition,
  preimageSubfulfillment   [1] PreimageSubfulfillment,
  prefixSubfulfillment     [2] PrefixSubfulfillment,
  thresholdSubfulfillment  [3] ThresholdSubfulfillment,
  rsaSha256Subfulfillment  [4] RsaSha256Subfulfillment,
  ed25519Subfulfillment    [5] Ed25519Subfulfillment
}
]]></artwork></figure>

<t>The internal structure of a fulfillment is a SEQUENCE of one or more sub-fulfillments where any compound sub-fulfillments (PREFIX-SHA256 and THRESHOLD-SHA-256) contain references to other sub-fulfillments in the form of the index of that sub-fulfillment in this SEQUENCE.</t>

<t>The first sub-fulfillment in the SEQUENCE MUST be the root sub-fulfillment. i.e. No other sub-fulfillment may reference sub-fulfillment index 0.</t>

<t>All sub-fulfillments in the SEQUENCE (except the first sub-fulfillment, index: 0) MUST be referenced by another sub-fulfillment. Implementations that process fulfillment and find unreferenced sub-fulfillments MUST reject the fulfillment.</t>

<t>Implementors should note that the tag numbers for the Subfulfillment type do not correspond to the type ids in the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>. This is to accomodate the inclusion of unfulfilled conditions in the SEQUENCE of sub-fulfillments that make up a fulfillment.</t>

</section>
<section anchor="example" title="Example">

<t>The following ASN.1 value-type notation describes a fulfillment with 3 sub-fulfillments, one of which is a PREFIX-SHA-256 type and therefore also contains a sub-fulfillment. The 3rd sub-fulfillment of the root THRESHOLD-SHA-256 sub-fulfillment is a PREIMAGE-SHA-256 type crypto-condition and is not fulfilled.</t>

<t>Assuming the two RSA signatures are valid this fulfillment is valid as 2 of the 3 sub-fulfillments are provided and valid.</t>

<t>Note that even if the keys of the two RSA-SHA-256 sub-fulfillments are the same the signatures will differ as the signature of the sub-fulfillment with index 4 is verified against a prefixed message.</t>

<t>example Fulfillment :: {
       thresholdSubfulfillment : {
           threshold 2,
           subfulfillments {
               1, 2, 3
           }
       },
       rsaSha256Subfulfillment : {
           publicKey {
               modulus 1234567890,
               publicExponent 65537
           },
           signature '…'H
       },
       prefixSubfulfillment : {
           prefix '…'H,
           subfulfillment 4
       },
       unfulfilledSubcondition : preimageSha256Condition : {
           fingerprint '…'H,
           cost 65
       },
       rsaSha256Subfulfillment : {
           publicKey {
               modulus 1234567890,
               publicExponent 65537
           },
           signature '…'H
       }
   }</t>

</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. While support for additional crypto-condition types may be added in the future and will be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>, no other types are supported by this specification.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-maxcost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> preimage, plus the constant 32. The constant is added to ensure that even a zero length fulfillment reflects some processing cost. This prevents a large number of very small PREIMAGE-SHA-256 sub-fulfillments being used to construct a fulfillment that has a low calculated cost but a large real cost to process.</t>

<figure><artwork><![CDATA[
cost = preimage + 32
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
-- The PREIMAGE-SHA-256 condition fingerprint content is not DER encoded
-- The fingerprint content is the preimage

-- Fulfillment 
PreimageSubfulfillment ::= SEQUENCE {
  preimage OCTET STRING
}
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the <spanx style="strong">unencoded</spanx> preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment simply contains the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by its sub-crypto-condition as it is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to narrow the scope of other crypto-conditions that are used inside the prefix crypto-condition as a sub-crypto-condition.</t>

<t>Because a condition is the fingerprint of a public key, by creating a prefix crypto-condition that wraps another crypto-condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple crypto-conditions, each with a different prefix, and therefore generate a unique condition and fulfillment each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-cost" title="Cost">

<t>The cost is the size, in bytes, of the <spanx style="strong">unencoded</spanx> prefix plus the cost of the sub-condition multiplied by 1.25.</t>

<figure><artwork><![CDATA[
cost = prefix.length + ( subcondition.cost * 1.25 )
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
PrefixSha256FingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}

-- Fulfillment 
PrefixSubfulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment INTEGER (1..65535)
}
]]></artwork></figure>

</section>
<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents which are identical 
to contents of the PrefixSubfulfillment.</t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation of the sub-fulfillment.</t>
  <t hangText='subcondition'>
  is the index of the sub-fulfillment</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>The fulfillment (f) that satisfies F.subcondition is valid, where the message used for validation of f is M prefixed by F.prefix AND</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by any of its sub-crypto-conditions as it is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-cost" title="Cost">

<t>The cost is the sum of the F.threshold largest cost values of all sub-conditions, added to 32 times the difference between the total sub-conditions and F.threshold.</t>

<figure><artwork><![CDATA[
cost = (sum of largest F.threshold subcondition.cost values) + 32 * (F.subconditions.count - F.threshold)
]]></artwork></figure>

<t>For example, if a threshold crypto-condition contains 5 sub-conditions with costs of 64, 64, 82, 84 and 84 and has a threshold of 3, the cost is equal to the sum of the largest three sub-condition costs (82 + 84 + 84 = 250) plus 32 times the number of remaining conditions (32 * (5 - 3) = 64): 314</t>

<t>Implementations MUST accept THRESHOLD-SHA-256 fulfillments with more sub-fulfillments provided that satisfy the sub-conditions than required by the threshold. In a complex multi-layer fulfillment, sub-fulfillments may be provided that satisfy sub-conditions within multiple compound conditions therefor it is impossible to avoid providing more sub-fulfillments than are required in some cases.</t>

<t>Implementations SHOULD only validate as many sub-fulfillments as are required to meet the threshold, favouring those with lower cost where possible.</t>

</section>
<section anchor="threshold-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subconditions SEQUENCE OF Condition
}

-- Fulfillment 
ThresholdSubfulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subfulfillments SEQUENCE OF INTEGER (1..65535)
}
]]></artwork></figure>

</section>
<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents as defined above. The SEQUENCE of DER encoded sub-conditions is sorted first based on encoded length, shortest first and then elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 65535. In order to fulfill a threshold condition, the count of the sub-conditions that are satisfied by one of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set indexes of sub-fulfillments, F.threshold of which MUST be satisfied by provided fulfillments.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>The number of F.subconditions, satisfied by provided fulfillments, is equal to or greater than F.threshold.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256 digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC8017"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefore, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC8017"></xref>. The algorithm parameters to use, as defined in <xref target="RFC4055"></xref> are:</t>

<figure><artwork><![CDATA[
pkcs-1 OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }

id-sha256 OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }

sha256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-sha256,
  parameters nullParameters  
}
                          
id-mgf1 OBJECT IDENTIFIER  ::=  { pkcs-1 8 }                          
                          
mgf1SHA256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-mgf1,
  parameters sha256Identifier 
}

rSASSA-PSS-SHA256-Params RSASSA-PSS-params ::=  {
  hashAlgorithm sha256Identifier,
  maskGenAlgorithm mgf1SHA256Identifier,
  saltLength 20,
  trailerField 1
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-cost" title="Cost">

<t>The cost is the square of RSA key modulus size (in bits) divided by the constant 64.</t>

<figure><artwork><![CDATA[
cost = ( (modulus size in bits) ^ 2 ) / 64 
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
RSASha256FingerprintContents ::= RSAPublicKey

-- Fulfillment 
RsaSha256Subfulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
      modulus INTEGER,  -- n
      publicExponent INTEGER -- e
}
]]></artwork></figure>

</section>
<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the DER encoded RSA Public Key encoded per the rules in <xref target="RFC8017"></xref>{#8017}.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t><list style="hanging">
  <t hangText='publicKey'>
  Implementations MUST use moduli greater than 128 bytes (1017 bits) and smaller than or equal to 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref>. OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref>.</t>
  <t>Implementations MUST use the value 65537 for the publicExponent e as recommended in <xref target="RFC4871"></xref>. Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref>. This constraint is not reflected in the ASN.1 definition as this would affect the encoding but MUST be enforced by implementations.</t>
  <t hangText='signature'>
  is an octet string representing the RSA signature.</t>
  <t>Implementations MUST verify that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref>. In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the RSA public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="ed25519-sha-256-condition-type" title="ED25519-SHA256">
<t>ED25519-SHA-256 is assigned the type ID 4. It relies on the SHA-256 and SHA-512 digest algorithms and the ED25519 signature scheme.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function for this signature scheme.</t>

<section anchor="ed25519-sha-256-condition-type-cost" title="Cost">

<t>The public key and signature are a fixed size therefore the cost for an ED25519 crypto-condition is fixed at 131072.</t>

<figure><artwork><![CDATA[
cost = 131072
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-asn1" title="ASN.1">

<figure><artwork><![CDATA[
-- Condition Fingerprint
Ed25519Sha256FingerprintContents ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32))
}

-- Fulfillment 
Ed25519Subfulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}
]]></artwork></figure>

</section>
<section anchor="ed25519-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519-SHA-256 condition is the SHA-256 digest of the DER encoded Ed25519 public key. While the public key is already very small and constant size, we hash it for consistency with the other types.</t>

</section>
<section anchor="ed25519-sha-256-condition-type-fulfillment" title="Fulfillment">

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example-1" title="Example">

<t>TODO</t>

</section>
</section>
</section>
<section anchor="uri-encoding-rules" title="URI Encoding Rules">

<t>Conditions can be encoded as URIs per the rules defined in the Named Information specification, <xref target="RFC6920"></xref>. There are no URI encoding rules for fulfillments.</t>

<t>Applications that require a string encoding for fulfillments MUST use an appropriate string encoding of the DER encoded binary representation of the fulfillment. No string encoding is defined in this specification. For consistency with the URI encoding of conditions, BASE64URL is recommended as described in <xref target="RFC4648"></xref>, Section 5.</t>

<t>The URI encoding is only used to encode top-level conditions and never for sub-conditions. The binary encoding is considered the canonical encoding.</t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are represented as URIs using the rules defined in <xref target="RFC6920"></xref> where the object being hashed is the DER encoded fingerprint content of the condition as described for the specific condition type.</t>

<t>While <xref target="RFC6920"></xref> allows for truncated hashes, implementations using the Named Information URI schemes for crypto-conditions MUST only use untruncated SHA-256 hashes (Hash Name: sha-256, ID: 1 from the "Named Information Hash Algorithm Registry" defined in <xref target="RFC6920"></xref>).</t>

</section>
<section anchor="new-uri-parameter-definitions" title="New URI Parameter Definitions">

<t><xref target="RFC6920"></xref> established the IANA registry of "Named Information URI Parameter Definitions". This specification defines three new definitions that are added to that registry and passed in URI encoded conditions as query string parameters.</t>

<section anchor="parameter-type" title="Parameter: type">

<t>The type parameter indicates the type of condition that is represented by the URI. The value MUST be one of the names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

</section>
<section anchor="parameter-cost" title="Parameter: cost">

<t>The cost parameter is the cost of the condition that is represented by the URI.</t>

</section>
<section anchor="parameter-subtypes" title="Parameter: subtypes">

<t>The subtypes parameter indicates the types of conditions that are subtypes of the condition represented by the URI. The value MUST be a comma seperated list of names from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

</section>
</section>
</section>
<section anchor="example-condition" title="Example Condition">

<t>An example condition (PREIMAGE-SHA-256):</t>

<figure><artwork><![CDATA[
0x00000000 A0 25 80 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 81 .%.....e...S.-..
0x00000010 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 00 H..].-K...w(J...
0x00000020 12 6D 90 69 81 01 0C                            .m.i...

ni:///sha-256;f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk?type=preimage-sha-256&cost=44
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>scheme</c>
      <c><spanx style="verb">ni://</spanx></c>
      <c>The named information scheme.</c>
      <c>hash function name</c>
      <c><spanx style="verb">sha-256</spanx></c>
      <c>The fingerprint is hashed with the SHA-256 digest function</c>
      <c>fingerprint</c>
      <c><spanx style="verb">f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk</spanx></c>
      <c>The fingerprint for this condition.</c>
      <c>type</c>
      <c><spanx style="verb">preimage-sha-256</spanx></c>
      <c>This is a [PREIMAGE-SHA-256][] condition.</c>
      <c>cost</c>
      <c><spanx style="verb">44</spanx></c>
      <c>The fulfillment payload is 12 bytes long, therefor the cost is (32 + 12): 44.</c>
</texttable>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3280;
&RFC4055;
&RFC4648;
&RFC6920;
&RFC8017;
&I-D.draft-irtf-cfrg-eddsa-08;
<reference anchor="itu.X680.2015" target="http://handle.itu.int/11.1002/1000/12479">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X690.2015" target="http://handle.itu.int/11.1002/1000/12483">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This specification has a normative dependency on a number of other specifications with extensive security considerations therefore the consideratons defined for SHA-256 hashing and RSA signatures in <xref target="RFC8017"></xref> and <xref target="RFC4055"></xref> and for ED25519 signatures in <xref target="I-D.irtf-cfrg-eddsa"></xref> must be considered.</t>

<t>The cost and subtypes values of conditions are provided to allow implementations to evaluate their ability to validate a fulfillment for the given condition later.</t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --></t>

<t>For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--
]]></artwork></figure>

<t>Crypto-Conditions DEFINITIONS EXPLICIT TAGS ::= BEGIN</t>

<figure><artwork><![CDATA[
-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
  modulus INTEGER,  -- n
  publicExponent INTEGER -- e
}

-- Core Structures

Crypto-Condition ::= Condition

Crypto-Fulfillment ::= Fulfillment

    --CONDITIONS

Condition ::= CHOICE {
  preimageSha256Condition  [0] Simple256Condition,
  prefixSha256Condition    [1] Compound256Condition,
  thresholdSha256Condition [2] Compound256Condition,
  rsaSha256Condition       [3] Simple256Condition,
  ed25519Sha256Condition   [4] Simple256Condition
}

Simple256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295)
}

Compound256Condition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  cost INTEGER (0..4294967295),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519Sha256   (4)
}

    --FULFILLMENTS

Fulfillment ::= SEQUENCE OF Subfulfillment

Subfulfillment ::= CHOICE {
  unfulfilledSubcondition  [0] Condition,
  preimageSubfulfillment   [1] PreimageSubfulfillment,
  prefixSubfulfillment     [2] PrefixSubfulfillment,
  thresholdSubfulfillment  [3] ThresholdSubfulfillment,
  rsaSha256Subfulfillment  [4] RsaSha256Subfulfillment,
  ed25519Subfulfillment    [5] Ed25519Subfulfillment
}

PreimageSubfulfillment ::= SEQUENCE {
  preimage OCTET STRING
}

PrefixSubfulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment INTEGER (1..65535)
}

ThresholdSubfulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subfulfillments SEQUENCE OF INTEGER (1..65535)
}

RsaSha256Subfulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

Ed25519Subfulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}

    --FINGERPRINTS

-- The PREIMAGE-SHA-256 condition fingerprint content is not encoded
-- The fingerprint content is the preimage

PrefixSha256FingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}

ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subconditions SEQUENCE OF Condition
}

RSASha256FingerprintContents ::= RSAPublicKey

Ed25519Sha256FingerprintContents ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32))
}
]]></artwork></figure>

<t>END</t>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

