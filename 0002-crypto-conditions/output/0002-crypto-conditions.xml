<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3280 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3280.xml">
<!ENTITY RFC8017 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8017.xml">
<!ENTITY RFC4055 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-08 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-08.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="December" day="13"/>

    <area>security</area>
    
    

    <abstract>


<t>The crypto-conditions specification defines a set of encoding formats and data structures for <spanx style="strong">conditions</spanx> and <spanx style="strong">fulfillments</spanx>.  A condition uniquely identifies a logical "boolean circuit" constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that define the structure of the circuit and provide inputs to the logic gates allowing for the result of the circuit to be evaluated.</t>

<t>A fulfillment is validated by evaluating that the circuit output is TRUE but also that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different types of crypto-conditions each have different internal strutures and employ different cryptographic algorithms as primitives.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding of common cryptographic primitives with hardcoded parameters, e.g RSA and ED25519 signature or SHA256 hash digests. As such, simple types that use the same underlying scheme (e.g. SHA) with different parameters (e.g. 256 or 512 bits) are considered different crypto-condition types.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm to generate the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition generated using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. The compound crypto-condition will evaluate to TRUE or FALSE based on the output of the evaluation of the sub-crypto-conditions. In this way compound crypto-conditions are used to construct branches of a boolean circuit.</t>

<t>To validate a compound crypto-condition all sub-crypto-conditions are provided in the fulfillment so that the fingerprint of the compound condition can be generated. However, some of these sub-crypto-conditions may be sub-fulfillments and some may be sub-conditions, depending on the type and properties of the compound crypto-condition.</t>

<t>As an example, in the case of an m-of-n signature scheme, only m sub-fulfillments are needed to validate the compound signature, but the remaining n-m sub-conditions must still be provided to validate that the complete fulfillment matches the originally provided condition. This is an important feature for multi-party signing, when not all parties are ready to provide fulfillment yet all parties still desire fulfillment of the overall condition if enough counter-parties do provide fulfillment.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and Supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefore it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility. That said, it is important that implementations must inspect the ypes and subtypes of any crypto-conditions they encounter to ensure they do not pass on a condition they will not be able to verify at a later stage.</t>

<t>In many instances protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:
  1. Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input
  2. The same public key can be used to validate multiple different signatures, each against a different message
  3. It is not possible to derive the signature from the public key</t>

<t>However, the scheme also has a number of features that make it unique such as:
  1. It is possible to derive the same public key from any valid signature without the message
  2. It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.
  3. Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.<vspace />
  4. A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefore conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefore <spanx style="strong">cryptographically verifiable event notifications</spanx> that can be used to verify the event occurred but also that it matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefore the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide non-repudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, follows these steps:</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F however in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and if neccessary calculate the hash digest of this data.</t>
  <t>Calculate the maximum fulfillment length of a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>.</t>

<section anchor="encoding-rules" title="Encoding Rules">

<t>Implementations of this specificiation MUST support encoding and decoding using Distinguished Encoding Rules (DER) as defined in <xref target="itu.X690.2015"></xref>. This is the canonical encoding format.</t>

<t>Alternative encodings may be used to represent top-level conditions and fulfillments but to ensure a determinisitic outcome in producing the condition fingerprint content, including any sub-conditions, MUST be DER encoded prior to hashing (if hashing is required).</t>

</section>
<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions differs based on their type. All types define at least a fingerprint and maxFulfillmentLength sub-field. Some types, such as the compound condition types, define additional sub-fields that are required to convey essential properties of the crypto-condition (such as the sub-types used by sub-conditions in the case of the compound types).</t>

<t>Each crypto-condition type has a type ID. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= CHOICE {
      preimageSha256 SimpleCondition,
      prefixSha256 CompoundCondition,
      thresholdSha256 CompoundCondition,
      rsaSha256 SimpleCondition,
      ed25519 SimpleCondition
}

SimpleCondition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxFulfillmentLength INTEGER (0..MAX)
}

CompoundCondition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxFulfillmentLength INTEGER (0..MAX),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519         (4)
}
]]></artwork></figure>

<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions <spanx style="strong">of the same type</spanx>.</t>

<t>Implementations which index conditions MUST use the complete encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This means the fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint which may have different lengths therefore the field is encoded as a variable length string.</t>

</section>
<section anchor="maxfulfillmentlength" title="MaxFulfillmentLength">

<t>This is the maximum length of the fulfillment payload for a fulfillment that can fulfill this condition.</t>

<t>For each crypto-condition type, an algorithm is provided for consistently calculating the maximum fulfillment length to ensure that implementations produce deterministic output.</t>

<t>When a crypto-condition is submitted to an implementation, this implementation MUST verify that it will be able to process a fulfillment with a payload of size maxFulfillmentLength.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>Subtypes is a bitmap that indicates the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of all sub-crypto-conditions, recursively.</t>

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available to be analysed yet. Therefore, all compound conditions set the bits in this bitmap that correspond to the set of types and subtypes of all sub-crypto-conditions.</t>

<t>The field is encoded as a variable length BIT STRING, as defined in ASN.1 to accommodate new types that may be defined.</t>

<t>Each bit in the bitmap represents a type from the list of known types in the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type.</t>

<t>The presence of one or more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>For example, a compound condition that contains an ED25519 crypto-condition as a sub-crypto-condition will set the bit at position 4.</t>

<t>Bits are numbered per the encoding rules for the ASN.1 BIT STRING type.</t>

</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>The ASN.1 definition for fulfillments is defined as follows:</t>

<figure><artwork><![CDATA[
Fulfillment ::= CHOICE {
      preimage PreimageFulfillment ,
      prefix PrefixFulfillment,
  threshold ThresholdFulfillment,
      rsaSha256 RsaSha256Fulfillment,
      ed25519 Ed25519Fulfillment
}

PreimageFulfillment ::= OCTET STRING

PrefixFulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}

ThresholdFulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subfulfillments SEQUENCE OF Fulfillment,
  subconditions SEQUENCE OF Condition
}

RsaSha256Fulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

Ed25519Fulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}

-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
      modulus INTEGER,  -- n
      publicExponent INTEGER -- e
}
]]></artwork></figure>

</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. While support for additional crypto-condition types may be added in the future and will be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>, no other types are supported by this specification.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the unencoded preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
PreimageFulfillment ::= OCTET STRING (SIZE (32))
]]></artwork></figure>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>examplePreimageCondition Condition ::= 
  preimageSha256 : 
  {
    fingerprint '7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069'H,
    maxFulfillmentLength 12
  }</t>

<t>DER Encoded 
A025 - CHOICE: preimageSha256 SimpleCondition SEQUENCE: tag = [0] constructed; length 37 bytes;
  8020 - fingerprint OCTET STRING: tag = [0] primitive; length = 32 bytes;
    7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069 - fingerprint value;
  8101 - maxFulfillmentLength INTEGER: tag = [1] primitive; length = 1 byte;
    0C - maxFulfillmentLength value = 12;</t>

<t>examplePreimageFulfillment Fulfillment ::= 
  preimage '48 65 6C 6C 6F 20 57 6F 72 6C 64 21'H</t>

<t>DER Encoded 
  800C - CHOICE: preimage PreimageFulfillment OCTET STRING: tag = [0] primitive; length = 12 bytes;
    4865 6C6C6F20 576F726C 6421 - preimage value: "Hello World!"</t>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by its sub-crypto-condition as it is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to narrow the scope of other crypto-conditions that are used inside the prefix crypto-condition as a sub-crypto-condition.</t>

<t>Because a condition is the fingerprint of a public key, by creating a prefix crypto-condition that wraps another crypto-condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple crypto-conditions, each with a different prefix, and therefore generate a unique condition and fulfillment each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents as defined below:</t>

<figure><artwork><![CDATA[
PrefixSha256ConditionFingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subcondition'>
  is the sub-condition derived from the sub-fulfillment.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the DER encoded prefix, including the tag and length indicator byte(s), plus the maxFulfillmentLength of the sub-crypto-condition.</t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
PrefixFulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subfulfillment'>
  is the fulfilled subcondition.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>F.subfulfillment is valid, where the message used for validation of F.subfulfillment is M prefixed by F.prefix AND</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and any other algorithms required by any of its sub-crypto-conditions as it is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents given below:</t>

<figure><artwork><![CDATA[
ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (0..65535),
  subconditions SEQUENCE OF Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='threshold'>
  threshold MUST be an integer in the range 0 … 65535. In order to fulfill a threshold condition, the number of valid sub-fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions.</t>
  <t>The list of DER encoded sub-conditions is sorted first based on encoded length, shortest first. Elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the the sum of the F.threshold largest maxFulfillmentLength values of all sub-conditions where, added to the size of the encoded length of the remaining sub-conditions and the encoded length of the threshold value.</t>

<t>For example, if a threshold crypto-condition contains 5 sub-conditions with maxFulfillment lengths of 64 bytes, 64 bytes, 82 bytes, 84 bytes and 84 bytes and encoded sizes of 34 bytes, 34 bytes, 34 bytes, 68 bytes and 68 bytes respectively and has a threshold of 3, the maxfulfillmentlength is equal to the sum of the largest three sub-condition maxfulfillmentlengths (82 + 84 + 84) plus the lengths of the remaining conditions (34 + 34) plus the encoded lenght of the threshold (3): 321 bytes</t>

<t>Implementations SHOULD provide only the number of sub-fulfillments required by the threshold as providing more may result in the fulfillment length exceeding the stated maxFulfillmentLength.</t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
ThresholdFulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subfulfillments SEQUENCE OF Fulfillment,
  subconditions SEQUENCE OF Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 65535. In order to fulfill a threshold condition, the count of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subfulfillments'>
  is the set of sub-fulfillments.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions provided in place of any unfulfilled sub-fulfillment.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>The number of valid F.subfulfillments is equal to or greater than F.threshold.</t>
  <t>D is equal to C.</t>
</list></t>

<t>For each subfulfillment the subfulfillment is validated against the message, and the subcondition for that fulfillment is derived. When all subfulfillments have been processed the derived subconditions and the provided subconditions are combined and sorted as defined by the condition formatting rules and the fingerprint and condition (D) is derived from the sequence of these subconditions.</t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256 digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC8017"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefore, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC8017"></xref>. The algorithm parameters to use, as defined in <xref target="RFC4055"></xref> are:</t>

<figure><artwork><![CDATA[
pkcs-1 OBJECT IDENTIFIER  ::=  { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }

id-sha256 OBJECT IDENTIFIER  ::=  { joint-iso-itu-t(2) country(16) us(840) organization(1) gov(101) csor(3) nistalgorithm(4) hashalgs(2) 1 }

sha256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-sha256,
  parameters nullParameters  
}
                          
id-mgf1 OBJECT IDENTIFIER  ::=  { pkcs-1 8 }                          
                          
mgf1SHA256Identifier AlgorithmIdentifier  ::=  {
  algorithm id-mgf1,
  parameters sha256Identifier 
}

rSASSA-PSS-SHA256-Params RSASSA-PSS-params ::=  {
  hashAlgorithm sha256Identifier,
  maskGenAlgorithm mgf1SHA256Identifier,
  saltLength 20,
  trailerField 1
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the DER encoded fingerprint contents given below:</t>

<figure><artwork><![CDATA[
RSASha256FingerprintContents ::= RSAPublicKey

-- IMPORTS from [RFC8017]{#8017}
RSAPublicKey ::= SEQUENCE {
      modulus INTEGER,  -- n
      publicExponent INTEGER -- e
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  the RSA public modulus n.</t>
  <t>Implementations MUST reject moduli smaller than 128 bytes (1017 bits) or greater than 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref>. OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref>.</t>
  <t hangText='publicExponent'>
  The corresponding publicExponent e is constrained to be the value 65537 as recommended in <xref target="RFC4871"></xref>. Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref>. This constraint is not reflected in the ASN.1 definition as this would affect the encoding but MUST be enforced by implementations.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The MaxFulfillmentLength is the sum of the encoded length of the publicKey and the signature. The signature MUST be the same encoded length as the publicKey.modulus (even if this means adding leading zeros) therefor it is possible to calculate the MaxFulfillmentLength using just the public key.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
RsaSha256FulfillmentPayload ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='publicKey'>
  is the DER encoded RSA public key</t>
  <t hangText='signature'>
  is an octet string representing the RSA signature. It MUST be encoded in big-endian byte order. with the exact same number of octets as the modulus of the public key, even if this means adding leading zeros. This ensures that the fulfillment size is constant and known ahead of time. Note that the field is still binary encoded with a length prefix for consistency.</t>
  <t>Implementations MUST verify that the signature and modulus consist of the same number of octets and that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref>. In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the RSA public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="ed25519-condition-type" title="ED25519">
<t>ED25519 is assigned the type ID 4. It relies on the SHA-512 digest algorithm and the ED25519 signature scheme as the condition fingerprint is not a digest.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function for this signature scheme.</t>

<section anchor="ed25519-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519 condition is the 32 byte Ed25519 public key. Since the public key is already very small and constant size, we do not hash it.</t>

<t>Ed25519FingerprintContents ::= OCTET STRING (SIZE(32))</t>

</section>
<section anchor="ed25519-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The public key and signature are a fixed size therefore the max fulfillment length for an ED25519 crypto-condition is fixed at .</t>

</section>
<section anchor="ed25519-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
Ed25519Fulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example" title="Example">

</section>
</section>
</section>
<section anchor="uri-encoding-rules" title="URI Encoding Rules">

<t>Implementations MUST support these encoding rules for encoding conditions and fulfillments as URIs. The URI encoding is only used to encode top-level conditions and fulfillments and never for sub-conditions and sub-fulfillments. The binary encoding is considered the canonical encoding.</t>

<t>The following types are defined for the URI encoding:</t>

<t><list style="hanging">
  <t hangText='BASE10'>
  Variable-length integer encoded as a base-10 (decimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows.</t>
  <t hangText='BASE16'>
  Variable-length integer encoded as a base-16 (hexadecimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows. Encodings may have an odd number of characters as the encoding excludes leading zeros.</t>
  <t hangText='BASE64URL'>
  Base64-URL encoding. See <xref target="RFC4648"></xref>, Section 5.</t>
</list></t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are ASCII encoded as per the ASN.1 data structure with a URI scheme of "cc" and the following encoding rules for invidual fields, whicha re each separated by the colon (":") character:</t>

<t><list style="numbers">
  <t>The CHOICE ASN.1 type is represented by the type name from the <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>. The convention is to encode this value in lowercase but since URIs are not case sensitive this is not a normative requirement and implementations MUST accept values in any case.</t>
  <t>The fingerprint field, defined as an OCTET STRING in ASN.1 is encoded as a BASE64URL string for the URI.</t>
  <t>The maxFulfillmentLength field, defined as an INTEGER in ASN.1 is encoded as a BASE10 string representation of the number.</t>
  <t>The subtypes field, present for compound crypto-condition types, is represented as a comma separated list of the type names of all sub-types.</t>
</list></t>

<t>The resulting encoding looks as follows for a simple condition:
    "cc:" type-name ":" BASE64URL(fingerprint) ":" BASE10(maxFulfillmentLength)</t>

<t>And as follows for a compound condition:  <vspace />
    "cc:" type-name ":" BASE64URL(fingerprint) ":" BASE10(maxFulfillmentLength) ":" subtype-name1,subtype-name2,subtype-nameN</t>

<section anchor="example-condition" title="Example Condition">

<t>An example condition (PREIMAGE-SHA-256):</t>

<figure><artwork><![CDATA[
0x00000000 A0 25 80 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 81 .%.....e...S.-..
0x00000010 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 00 H..].-K...w(J...
0x00000020 12 6D 90 69 81 01 0C                            .m.i...

cc:preimage-sha-256:f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk:12
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cc</spanx></c>
      <c>Constant. Indicates this is a condition.</c>
      <c>type</c>
      <c><spanx style="verb">preimage-sha-256</spanx></c>
      <c>This is a [PREIMAGE-SHA-256][] condition.</c>
      <c>fingerprint</c>
      <c><spanx style="verb">f4OxZX_x_FO5LcGBSKHWXfwtSx-j1ncoSt3SABJtkGk</spanx></c>
      <c>The fingerprint for this condition.</c>
      <c>maxFulfillmentLength</c>
      <c><spanx style="verb">12</spanx></c>
      <c>The fulfillment payload is 12 bytes long, before being BASE64URL-encoded.</c>
</texttable>

</section>
<section anchor="string-fulfillment-format" title="Fulfillment URI Format">

<t>Fulfillments are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cf:" BASE64URL(DER encoded fulfillment)
]]></artwork></figure>

</section>
<section anchor="example-fulfillment" title="Example Fulfillment">

<t>The following is an example fulfillment in string format, for the <xref target="example-condition">example condition</xref>:</t>

<figure><artwork><![CDATA[
cf:gAxIZWxsbyBXb3JsZCE
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cf</spanx></c>
      <c>Constant. Indicates this is a fulfillment.</c>
      <c>fulfillment</c>
      <c><spanx style="verb">gAxIZWxsbyBXb3JsZCE</spanx></c>
      <c>The BASE64URL-encoded fulfillment.</c>
</texttable>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3280;
&RFC8017;
&RFC4055;
&RFC4648;
&I-D.draft-irtf-cfrg-eddsa-08;
<reference anchor="itu.X680.2015" target="http://handle.itu.int/11.1002/1000/12479">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X690.2015" target="http://handle.itu.int/11.1002/1000/12483">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This specification has a normative dependency on a number of other specifications with extensive security considerations therefore the consideratons defined for SHA-256 hashing and RSA signatures in <xref target="RFC8017"></xref>{#RFC8017} and <xref target="RFC4055"></xref>{#RFC4055} and for ED25519 signatures in [I-D.irtf-cfrg-eddsa]{#I-D.irtf-cfrg-eddsa} must be considered.</t>

<t>The MaxFulfillmentLength and subtypes values of conditions are provided to allow implementations to evaluate their ability to validate a fulfillment for the given condition later. Implementations must ensure that processing a fulfillment of the specified size will not result in any overflow errors that may introduce security risks.</t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --></t>

<t>For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--

CryptoConditions
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

IMPORTS

AlgorithmIdentifier
  FROM PKIX1Explicit88 -- Found in [RFC3280](#RFC3280)
    { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-explicit(18) } ;


IMPORTS

pkcs-1, id-sha256, sha256Identifier, id-mgf1, mgf1SHA256Identifier, RSAPublicKey, rSASSA-PSS-SHA256-Identifier, rSASSA-PSS-SHA256-Params
  FROM PKIX1-PSS-OAEP-Algorithms -- Found in [RFC4055](#RFC4055)
    { iso(1) identified-organization(3) dod(6) internet(1) security(5) mechanisms(5) pkix(7) id-mod(0) id-mod-pkix1-rsa-pkalgs(33) } ;

Condition ::= CHOICE {
      preimageSha256 SimpleCondition,
      prefixSha256 CompoundCondition,
      thresholdSha256 CompoundCondition,
      rsaSha256Condition SimpleCondition,
      ed25519Condition SimpleCondition
}

SimpleCondition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxFulfillmentLength INTEGER (0..MAX)
}

CompoundCondition ::= SEQUENCE {
  fingerprint OCTET STRING (SIZE(32)),
  maxFulfillmentLength INTEGER (0..MAX),
  subtypes ConditionTypes
}

ConditionTypes ::= BIT STRING {
  preImageSha256  (0),
  prefixSha256    (1),
  thresholdSha256 (2),
  rsaSha256       (3),
  ed25519         (4)
}

Fulfillment ::= CHOICE {
      preimage PreimageFulfillment ,
      prefix PrefixFulfillment,
  threshold ThresholdFulfillment,
      rsaSha256 RsaSha256Fulfillment,
      ed25519 Ed25519Fulfillment
}

PreimageFulfillment ::= OCTET STRING

PrefixFulfillment ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}

ThresholdFulfillment ::= SEQUENCE {
  threshold INTEGER (1..65535),
  subfulfillments SEQUENCE OF Fulfillment,
  subconditions SEQUENCE OF Condition
}

RsaSha256Fulfillment ::= SEQUENCE {
  publicKey RSAPublicKey,
  signature OCTET STRING
}

Ed25519Fulfillment ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}


/**
* FINGERPRINT CONTENTS
*
* The content that will be hashed to arrive at the fingerprint.
*/

-- The preimage type hashes the raw contents of the preimage

PrefixSha256FingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  condition Condition
}

ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (0..65535),
  subconditions SEQUENCE OF Condition,
}

RsaSha256FingerprintContents ::= RSAPublicKey



/**
* EXAMPLES
*/

examplePreimageCondition Condition ::= 
  preimageSha256 : 
  {
    fingerprint '7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069'H,
    maxFulfillmentLength 12
  }


/**
* DER Encoded 
*
* A0 25 - CHOICE: preimageSha256 SimpleCondition SEQUENCE: tag = [0] constructed; length 37 bytes;
*    80 20 - fingerprint OCTET STRING: tag = [0] primitive; length = 32 bytes;
*      7F83B165 7FF1FC53 B92DC181 48A1D65D FC2D4B1F A3D67728 4ADDD200 126D9069 - fingerprint value;
*    81 01 - maxFulfillmentLength INTEGER: tag = [1] primitive; length = 1 byte;
*      0C - maxFulfillmentLength value = 12;
*
*/

examplePreimageFulfillment Fulfillment ::= 
  preimage '48 65 6C 6C 6F 20 57 6F 72 6C 64 21'H

/**
* DER Encoded 
*
* 80 0C - CHOICE: preimage PreimageFulfillment OCTET STRING: tag = [0] primitive; length = 12 bytes;
*    4865 6C6C6F20 576F726C 6421 - preimage value: "Hello World!"


END
]]></artwork></figure>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>


  </back>

<!-- ##markdown-source:
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

-->

</rfc>

