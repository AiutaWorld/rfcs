<?xml version="1.0" encoding="utf-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.39 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3447 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3447.xml">
<!ENTITY RFC4648 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml">
<!ENTITY I-D.draft-irtf-cfrg-eddsa-04 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-04.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3110 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3110.xml">
<!ENTITY RFC4871 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4871.xml">
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc comments="yes"?>

<rfc docName="draft-thomas-crypto-conditions-02" category="std">

  <front>
    <title>Crypto-Conditions</title>

    <author initials="S." surname="Thomas" fullname="Stefan Thomas">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>stefan@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="R." surname="Reginelli" fullname="Rome Reginelli">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>rome@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>
    <author initials="A." surname="Hope-Bailie" fullname="Adrian Hope-Bailie">
      <organization>Ripple</organization>
      <address>
        <postal>
          <street>300 Montgomery Street</street>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94104</code>
          <country>US</country>
        </postal>
        <phone>-----------------</phone>
        <email>adrian@ripple.com</email>
        <uri>https://www.ripple.com</uri>
      </address>
    </author>

    <date year="2016" month="November" day="11"/>

    <area>security</area>
    
    

    <abstract>


<t>Crypto-conditions defines a set of encoding formats and data structures for conditions and fulfillments.  A condition uniquely identifies a boolean circuit constructed from one or more logic gates, evaluated by either validating a cryptographic signature or verifying the preimage of a hash digest. A fulfillment is a data structure encoding one or more cryptographic signatures and hash digest preimages that can be used to evaluate the result of the circuit.</t>

<t>A fulfillment is validated by evaluating the circuit but also verifying that the provided fulfillment matches the circuit fingerprint, the condition.</t>

<t>Since evaluation of some of the logic gates in the circuit (those that are signatures) also take a message as input the evaluation of the entire fulfillment takes an optional input message which is passed to each logic gate as required. As such the algorithm to validate a fulfillment against a condition and a message matches that of other signature schemes and a crypto-condition can serve as a sophisticated and flexible replacement for a simple signature where the condition is used as the public key and the fulfillment as the signature.</t>



    </abstract>


    <note title="Feedback">


<t>This specification is a part of the <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback related to this specification should be sent to <eref target="mailto:ledger@ietf.org">ledger@ietf.org</eref>.</t>


    </note>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>Crypto-conditions is a scheme for composing signature-like structures from one or more existing signature scheme or hash digest primitives. It defines a mechanism for these existing primitives to be combined and grouped to create complex signature arrangements but still maintain the useful properties of a simple signature, most notably, that a deterministic algorithm exists to verify the signature against a message given a public key.</t>

<t>Using crypto-conditions, existing primitives such as RSA and ED25519 signature schemes and SHA256 digest algorithms can be used as logic gates to construct complex boolean circuits which can then be used as a compound signature. The validation function for these compound signatures takes as input the fingerprint of the circuit, called the condition, the circuit definition and minimum required logic gates with their inputs, called the fulfillment, and a message.</t>

<t>The function returns a boolean indicating if the compound signature is valid or not. This property of crypto-conditions means they can be used in most scenarios as a replacement for existing signature schemes which also take as input, a public key (the condition), a signature (the fulfillment), and a message and return a boolean result.</t>

</section>
<section anchor="terminology" title="Terminology">
<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>

</section>
<section anchor="types" title="Types">
<t>Crypto-conditions are a standard format for expressing conditions and fulfillments. The format supports multiple algorithms, including different hash functions and cryptographic signing schemes. Crypto-conditions can be nested in multiple levels, with each level possibly having multiple signatures.</t>

<t>The different structures of different crypto-conditions and the algorithms they employ is defined by the type of the crypto-condition.</t>

<section anchor="simple-and-compound-types" title="Simple and Compound Types">

<t>Two categories of crypto-condition type exist. Simple crypto-conditions provide a standard encoding for existing primitives such as RSA and ED25519 signatures, or SHA256 hash digests where many of the scheme parameters have hardcoded values. As such multiple simple types maybe be defined to encode the same underlying scheme but where the parameters differ.</t>

<t>As an example, the types defined in this version of the specification all use the SHA-256 digest algorithm for derivation of the condition fingerprint. If a future version were to introduce SHA-512 as an alternative this would require that new types be defined for each existing type that must have its condition derived using SHA-512.</t>

<t>Compound crypto-conditions contain one or more sub-crypto-conditions. Compound crypto-conditions are used to construct the branches of the boolean circuit where a compound condition will evaluate to TRUE or FALSE based on the output of the evaluation of their sub-crypto-conditions.</t>

<t>A compound crypto-condition may have multiple branches and be defined to evaluate to TRUE even if only a subset of these evaluate to TRUE (as in an m-of-n signature scheme). As such the valid fulfillment of a compound condition could contain a combination of sub-fulfillments (that can be evaluated) but also sub-conditions that are simply used (in combination with the derived conditions from the sub-fulfillments) to derive the compound condition and compare this to the condition provided for validation.</t>

</section>
<section anchor="defining-and-supporting-new-types" title="Defining and supporting New types">

<t>The crypto-conditions format has been designed so that it can be expanded. For example, you can add new cryptographic signature schemes or hash functions. This is important because advances in cryptography frequently render old algorithms insecure or invent newer, more effective algorithms.</t>

<t>Implementations are not required to support all condition types therefor it is necessary to indicate which types an implementation must support in order to validate a fulfillment. For this reason, compound conditions are encoded with an additional field, subtypes, indicating the set of types and subtypes of all sub-crypto-conditions.</t>

</section>
</section>
<section anchor="features" title="Features">

<t>Crypto-conditions offer many of the features required of a regular signature scheme but also others which make them useful in a variety of new use cases.</t>

<section anchor="multi-algorithm" title="Multi-Algorithm">

<t>Each condition type uses one or more cryptographic primitives such as digest or signature algorithms. Compound types may contain sub-crypto-conditions of any type and indicate the set of underlying types in the subtypes field of the condition</t>

<t>To verify that a given implementation can verify a fulfillment for a given condition, implementations MUST ensure they are able to validate fulfillments of all types indicated in the subtypes field of a compound condition. If an implementation encounters an unknown type it MUST reject the condition as it will almost certainly be unable to validate the fulfillment.</t>

</section>
<section anchor="multi-signature" title="Multi-Signature">
<t>Crypto-conditions can abstract away many of the details of multi-sign. When a party provides a condition, other parties can treat it opaquely and do not need to know about its internal structure. That allows parties to define arbitrary multi-signature setups without breaking compatibility.</t>

<t>Protocol designers can use crypto-conditions as a drop-in replacement for public key signature algorithms and add multi-signature support to their protocols without adding any additional complexity.</t>

</section>
<section anchor="multi-level" title="Multi-Level">
<t>Crypto-conditions elegantly support weighted multi-signatures and multi-level signatures. A threshold condition has a number of subconditions, and a target threshold. Each subcondition can be a signature or another threshold condition. This provides flexibility in forming complex conditions.</t>

<t>For example, consider a threshold condition that consists of two subconditions, one each from Wayne and Alf. Alf's condition can be a signature condition while Wayne's condition is a threshold condition, requiring both Claude and Dan to sign for him.</t>

<t>Multi-level signatures allow more complex relationships than simple M-of-N signing. For example, a weighted condition can support an arrangement of subconditions such as, "Either Ron, Mac, and Ped must approve; or Smithers must approve."</t>

</section>
<section anchor="crypto-conditions-as-a-signature-scheme" title="Crypto-conditions as a signature scheme">

<t>Crypto-conditions is a signature scheme for compound signatures which has similar properties to most other signature schemes, such as:
  1. Validation of the signature (the fulfillment) is done using a public key (the condition) and a message as input
  2. The same public key can be used to validate multiple different signatures, each against a different message
  3. It is not possible to derive the signature from the public key</t>

<t>However, the scheme also has a number of features that make it unique such as:
  1. It is possible to derive the same public key from any valid signature without the message
  2. It is possible for the same public key and message to be used to validate multiple signatures. For example, the fulfillment of an m-of-n condition will be different for each combination of n signatures.
  4. Composite signatures use one or more other signatures as components allowing for recursive signature validation logic to be defined.<vspace />
  3. A valid signature can be produced using different combinations of private keys if the structure of the compound signature requires only specific combinations of internal signatures to be valid  (m of n signature scheme).</t>

</section>
<section anchor="crypto-conditions-as-a-trigger-in-distributed-systems" title="Crypto-conditions as a trigger in distributed systems">

<t>One of the challenges facing a distributed system is achieving atomic execution of a transaction across the system. A common pattern for solving this problem is two-phase commit in which the most time and resource-consuming aspects of the transaction are prepared by all participants following which a simple trigger is sufficient to either commit or abort the transaction. Described in more abstract terms, the system consists of a number of participants that have prepared a transaction pending the fulfillment of a predefined condition.</t>

<t>Crypto-conditions defines a mechanism for expressing these triggers as pairs of unique trigger identifiers (conditions) and cryptographically verifiable triggers (fulfillments) that can be deterministically verified by all participants.</t>

<t>It is also important that all participants in such a distributed system are able to evaluate, prior to the trigger being fired, that they will be capable of verifying the trigger. Determinism is useless if validation of the trigger requires algorithms or resources that are not available to all participants.</t>

<t>Therefor conditions may be used as <spanx style="strong">distributable event descriptions</spanx> in the form of a <spanx style="emph">fingerprint</spanx>, but also <spanx style="emph">event meta-data</spanx> that allows the event verification system to determine if they have the necessary capabilities (such as required crypto-algorithms) and resources (such as heap size or memory) to verify the event notification later.</t>

<t>Fulfillments are therefor <spanx style="strong">cryptographically verifiable event notifications</spanx> can be used to verify that the event occurred but also matches the given description.</t>

<t>When using crypto-conditions as a trigger it will often make sense for the message that is used for validation to be empty to match the signature of the trigger processing system's API. This makes crypto-conditions compatible with systems that use simple hash-locks as triggers.</t>

<t>If a PKI signature scheme is being used for the triggers this would require a new key pair for each trigger which is impractical. Therefor the PREFIX compound type wraps a sub-crypto-condition with a message prefix that is applied to the message before signature validation. In this way a unique condition can be derived for each trigger even if the same key pair is re-used with an empty message.</t>

</section>
<section anchor="smart-signatures" title="Smart signatures">

<t>In the Interledger protocol, fulfillments provide irrepudiable proof that a transaction has been completed on a ledger. They are simple messages that can be easily shared with other ledgers. This allows ledgers to escrow funds or hold a transfer conditionally, then execute the transfer automatically when the ledger sees the fulfillment of the stated condition. In this way the Interledger protocol synchronizes multiple transfers on distinct ledgers in an almost atomic end-to-end transaction.</t>

<t>Crypto-conditions may also be useful in other contexts where a system needs to make a decision based on predefined criteria, and the proof from a trusted oracle(s) that the criteria have been met, such as smart contracts.</t>

<t>The advantage of using crypto-conditions for such use cases as opposed to a turing complete contract scripting language is the fact that the outcome of a crypto-condition validation is deterministic across platforms as long as the underlying cryptographic primitives are correctly implemented.</t>

</section>
</section>
<section anchor="validation-of-a-fulfillment" title="Validation of a fulfillment">

<t>Validation of a fulfillment (F) against a condition (C) and a message (M), in the majority of cases, the following steps.</t>

<t><list style="numbers">
  <t>The implementation must derive a condition from the fulfillment and ensure that the derived condition (D) matches the given condition (C).</t>
  <t>If the fulfillment is a simple crypto-condition AND is based upon a signature scheme (such as RSA-PSS or ED25519) then any signatures in the fulfillment (F) must be verified, using the appropriate signature verification algorithm, against the corresponding public key, also provided in the fulfillment and the message (M) (which may be empty).</t>
  <t>If the fulfillment is a compound crypto-condition then the sub-fulfillments MUST each be validated. In the case of the PREFIX-SHA-256 type the sub-fulfillment MUST be valid for F to be valid and in the case of the THRESHOLD-SHA-256 type the number of valid sub-fulfillments must be equal or greater than the threshold defined in F.</t>
</list></t>

<t>If the derived condition (D) matches the input condition (C) AND the boolean circuit defined by the fulfillment evaluates to TRUE then the fulfillment (F) fulfills the condition (C).</t>

<t>A more detailed validation algorithm for each crypto-condition type is provided with the details of the type later in this document. In each case the notation F.x or C.y implies; the decoded value of the field named x of the fulfillment and the decoded value of the field named y of the Condition respectively.</t>

<section anchor="subfulfillments" title="Subfulfillments">

<t>In validating a fulfillment for a compound crypto-condition it is necessary to validate one or more sub-fulfillments per step 3 above. In this instance the condition for one or more of these sub-fulfillments is often not available for comparison with the derived condition. Implementations MUST skip the first fulfillment validation step as defined above and only perform steps 2 and 3 of the validation.</t>

<t>The message (M) used to validate sub-fulfillments is the same message (M) used to validate F howvere in the case of the PREFIX-SHA-256 type this is prefixed with F.prefix before validation of the sub-fulfillment is performed.</t>

</section>
</section>
<section anchor="deriving-the-condition" title="Deriving the Condition">

<t>Since conditions provide a unique fingerprint for fulfillments it is important that a determinisitic algorithm is used to derive a condition. For each crypto-condition type details are provided on how to:</t>

<t><list style="numbers">
  <t>Assemble the fingerprint content and if neccessary calculate the hash digest of this data.</t>
  <t>Calculate the maximum fulfillment length of a fulfillment</t>
</list></t>

<t>For compound types the fingerprint content will contain the complete, encoded, condition for all sub-crypto-conditions. Implementations MUST abide by the ordering rules provided when assembling the fingerprint content.</t>

<t>When calculating the fingerprint of a compound crypto-condition implementations MUST first derive the condition for all sub-fulfillments and include these conditions when assembling the fingerprint content.</t>

<section anchor="conditions-as-public-keys" title="Conditions as Public Keys">

<t>Since the condition is just a fingerprint and meta-data about the crypto-condition it can be transmitted freely in the same way a public key is shared publicly. It's not possible to derive the fulfillment from the condition.</t>

</section>
</section>
<section anchor="format" title="Format">

<t>A description of crypto-conditions is provided in this document using Abstract Syntax Notation One (ASN.1) as defined in <xref target="itu.X680.2015"></xref>. Implementations of this spec MUST support encoding and decoding using Octet Encoding Rules (OER) as defined in <xref target="itu.X696.2015"></xref>.</t>

<section anchor="condition-format" title="Condition">

<t>The binary encoding of conditions is dependant on their type. The overall size of conditions is not fixed as some types (compound conditions) contain additional fields (subtypes) and the algorithm for deriving the fingerprint differs by type therefor the fingerprint size also differs.</t>

<t>Conditions are encoded as follows:</t>

<figure><artwork><![CDATA[
Condition ::= SEQUENCE {
  type ConditionType,
  fingerprint OCTET STRING,
  maxFulfillmentLength INTEGER (0..MAX),
  subtypes OCTET STRING
}

ConditionType ::= INTEGER {
  preimageSha256(0),
  prefixSha256(1),
  thresholdSha256(2),
  rsaSha256(3),
  ed25519(4)
} (0..255)
]]></artwork></figure>

<section anchor="type" title="Type">

<t>Type is the numeric type identifier representing the condition type. In future new types may introduce new formats.</t>

</section>
<section anchor="fingerprint" title="Fingerprint">

<t>The fingerprint is an octet string uniquely representing the condition with respect to other conditions of the same type.</t>

<t>Implementations which index conditions MUST use the entire encoded condition as the key, not just the fingerprint - as different conditions of different types may have the same fingerprint.</t>

<t>For most condition types, the fingerprint is a cryptographically secure hash of the data which defines the condition, such as a public key.</t>

<t>For types that use PKI signature schemes, the signature is intentionally not included in the content that is used to compose the fingerprint. This meansthe fingerprint can be calculated without needing to know the message or having access to the private key.</t>

<t>Future types may use different functions to produce the fingerprint which may have different lengths therefor the filed is encoded as a variable length string.</t>

</section>
<section anchor="maxfulfillmentlength" title="MaxFulfillmentLength">

<t>This is the maximum length of the essential fulfillment payload for a fulfillment that can fulfill this condition.</t>

<t>For each crypto-condition type, a formula is provided for calculating the maximum fulfillment length to ensure that implementations produce consistent output.</t>

<t>When a crypto-condition is submitted to an implementation, this implementation MUST verify that it will be able to process a fulfillment with a payload of size maxFulfillmentLength plus any additional encoding bytes.</t>

</section>
<section anchor="subtypes" title="Subtypes">

<t>It must be possible to verify that all types used in a crypto-condition are supported (including the types and subtypes of any sub-crypto-conditions) even if the fulfillment is not available yet. Therefore, all compound conditions popluate a bitmap to indicate the set of types and subtypes of all sub-crypto-conditions. The subtypes field is only used in the compound conditions (THRESHOLD-SHA-256 and PREFIX-SHA-256), for simple conditions this field should be an empty string.</t>

<t>Implementations that encounter a condition with any of the simple types (PREIMAGE-SHA-256, RSA-SHA-256 or ED25519) and a sutypes field that is not an emtpty string MUST reject the condition.</t>

<t>The field is encoded as a variable length octet string. It specifies the set of types an implementation must support in order to be able to successfully validate the fulfillment of this condition. This is the set of types and subtypes of the top-level condition and all sub-crypto-conditions, recursively.</t>

<t>Each bit in the bitmap represents a type. The list of known types is the IANA-maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref> and the bit corresponding to each type is the bit at position X where X is the type ID of the type. The presence of one of more sub-crypto-conditions of a specific type is indicated by setting the numbered bit corresponding to the type ID of that type.</t>

<t>For example, a compound condition that contains an ED25519 crypto-condition as a sub-crypto-condition will set the bit at position 4.</t>

<t>Bits are numbered from the least significant bit of the first byte (position 0) to the most significant bit (position 7) and then again from the least significant bit of the next byte (position 8) to the most significant bit (position 15) an so on for all bytes in the bitmap.</t>

<section anchor="examples" title="Examples">

<t>The following bitmap indicates the presence of the subtypes PREIMAGE-SHA-256 (type number 0) and RSA-SHA-256 (type number 3)</t>

<figure><artwork><![CDATA[
Hex
1       
0x09

Binary
7       0          
0000 1001   
]]></artwork></figure>

<t>The following bitmap indicates the presence of the subtype ED25519 (type number 4)</t>

<figure><artwork><![CDATA[
Hex
1        
0x10 

Binary
7       0            
0001 0000  
]]></artwork></figure>

<t>The following bitmap indicates the presence of an unknown subtype with type number 10.</t>

<figure><artwork><![CDATA[
Hex
1    2       
0x00 0x04

Binary
7       0  15       8            
0000 0000   0000 0100   
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="fulfillment-format" title="Fulfillment">

<t>Like conditions, the binary encoding of fulfillments is dependant on their type. 
Unlike conditions there is little commonality between types, the only common field being the type which is encoded in the first byte.</t>

<t>Therefor the ASN.1 definition for fulfillments is defined as follows and the format of the payload is defined per type:</t>

<figure><artwork><![CDATA[
Fulfillment ::= SEQUENCE {
  type ConditionType,
  payload OCTET STRING,
}
]]></artwork></figure>

</section>
</section>
<section anchor="crypto-condition-types" title="Crypto-Condition Types">
<t>The following condition types are defined in this version of the specification. Future versions of this spec MAY introduce new feature suites and condition types, which SHALL be registered in the IANA maintained <xref target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>.</t>

<section anchor="preimage-sha-256-condition-type" title="PREIMAGE-SHA-256">

<t>PREIMAGE-SHA-256 is assigned the type ID 0. It relies on the availability of the SHA-256 digest algorithm.</t>

<t>This type of condition is also called a "hashlock". By creating a hash of a difficult-to-guess 256-bit random or pseudo-random integer it is possible to create a condition which the creator can trivially fulfill by publishing the random value. However, for anyone else, the condition is cryptographically hard to fulfill, because they would have to find a preimage for the given condition hash.</t>

<t>Implementations MUST ignore any input message when validating a PREIMAGE-SHA-256 fulfillment as the validation of this crypto-condition type only requires that the SHA-256 digest of the preimage, taken from the fulfillment, matches the fingerprint, taken from the condition.</t>

<section anchor="preimage-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREIMAGE-SHA-256 condition is the SHA-256 hash of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<t>The fulfillment payload is simply the preimage.</t>

</section>
<section anchor="preimage-sha-256-condition-type-validating" title="Validating">

<t>A PREIMAGE-SHA-256 fulfillment is valid iff C.fingerprint is equal to the SHA-256 hash digest of F.preimage.</t>

</section>
<section anchor="preimage-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="prefix-sha-256-condition-type" title="PREFIX-SHA-256">
<t>PREFIX-SHA-256 is assigned the type ID 1. It relies on the availability of the SHA-256 digest algorithm and is a compound crypto-condition type.</t>

<t>Prefix crypto-conditions provide a way to effectively narrow the scope of other crypto-conditions.</t>

<t>A condition is the fingerprint of a public key used to sign an arbitrary message. By creating a prefix crypto-condition that wraps another condition we can narrow the scope from signing an arbitrary message to signing a message with a specific prefix.</t>

<t>We can also use the prefix condition in contexts where there is an empty message used for validation of the fulfillment so that we can reuse the same key pair for multiple fulfillments, each with a different prefix, and therefore generate a unique condition each time.</t>

<t>Implementations MUST prepend the prefix to the provided message and will use the resulting value as the message to validate the sub-fulfillment.</t>

<section anchor="prefix-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a PREFIX-SHA-256 condition is the SHA-256 digest of the fingerprint contents as defined below:</t>

<figure><artwork><![CDATA[
PrefixSha256ConditionFingerprintContents ::= SEQUENCE {
  prefix OCTET STRING,
  subcondition Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subcondition'>
  is the sub-condition derived from the sub-fulfillment.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the size, in bytes, of the prefix plus the maxFulfillmentLength of the sub-crypto-condition.</t>

</section>
<section anchor="prefix-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
PrefixSha256FulfillmentPayload ::= SEQUENCE {
  prefix OCTET STRING,
  subfulfillment Fulfillment
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='prefix'>
  is an arbitrary octet string which will be prepended to the message during validation.</t>
  <t hangText='subfulfillment'>
  is the fulfilled subcondition.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-condition-type-validating" title="Validating">

<t>A PREFIX-SHA-256 fulfillment is valid iff:</t>

<t><list style="numbers">
  <t>F.subfulfillment is valid, where the message used for validation of F.subfulfillment is M prefixed by F.prefix AND</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="prefix-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="threshold-sha-256-condition-type" title="THRESHOLD-SHA-256">
<t>THRESHOLD-SHA-256 is assigned the type ID 2. It relies on the availability of the SHA-256 digest algorithm and is a compound crypto-condition type.</t>

<section anchor="threshold-sha-256-condition-type-condition" title="Condition Format">

<t>The fingerprint of a THRESHOLD-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
ThresholdSha256FingerprintContents ::= SEQUENCE {
  threshold INTEGER (1..255),
  subconditions SEQUENCE OF Condition,
}
]]></artwork></figure>

<t>The list of sub-conditions is sorted first based on length, shortest first. Elements of the same length are sorted in lexicographic (big-endian) order, smallest first.</t>

<t><list style="hanging">
  <t hangText='threshold'>
  threshold MUST be an integer in the range 1 … 255. In order to fulfill a threshold condition, the number of valid sub-fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions either provided in the fulfillment or derived from the sub-fulfillments provided.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is sum of the maxFulfillmentLength of all sub-conditions and sub-fulfillments.</t>

</section>
<section anchor="threshold-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
ThresholdSha256FulfillmentPayload ::= SEQUENCE {
  threshold INTEGER (0..255),
  subfulfillments SEQUENCE OF Fulfillment
  subconditions SEQUENCE OF Condition
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='threshold'>
  is a number and MUST be an integer in the range 1 … 255. In order to fulfill a threshold condition, the sum of the provided fulfillments MUST be greater than or equal to the threshold.</t>
  <t hangText='subfulfillments'>
  is the set of sub-fulfillments.</t>
  <t hangText='subconditions'>
  is the set of sub-conditions provided in place of any unfufilled sub-fulfillment.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-condition-type-validating" title="Validating">

<t>A THRESHOLD-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>The number of valid F.subfulfillments is equal to or greater than F.threshold.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="threshold-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="rsa-sha-256-condition-type" title="RSA-SHA-256">
<t>RSA-SHA-256 is assigned the type ID 3. It relies on the SHA-256  digest algorithm and the RSA-PSS signature scheme.</t>

<t>The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2. <xref target="RFC3447"></xref></t>

<t>Implementations MUST NOT use the default RSASSA-PSS-params. Implementations MUST use the SHA-256 hash algorithm and therefor, the same algorithm in the mask generation algorithm, as recommended in <xref target="RFC3447"></xref>. Implementations MUST also use a salt length of 32 bytes (equal to the size of the output from the SHA-256 algorithm). Therefore the algorithm identifier will have the following value:</t>

<figure><artwork><![CDATA[
rSASSA-PSS-Crypto-Conditions-Identifier  RSASSA-AlgorithmIdentifier ::= {
    algorithm   id-RSASSA-PSS,
    parameters  RSASSA-PSS-params : {
        hashAlgorithm       sha256,
        maskGenAlgorithm    mgf1SHA256,
        saltLength          32,
        trailerField        trailerFieldBC
    }
}
   
sha256 HashAlgorithm ::= {
    algorithm   id-sha256,
    parameters  NULL
}

mgf1SHA256 MaskGenAlgorithm ::= {
    algorithm   id-mgf1,
    parameters  HashAlgorithm : sha256
}
]]></artwork></figure>

<section anchor="rsa-sha-256-condition-type-condition" title="Condition Format">
<t>The fingerprint of a RSA-SHA-256 condition is the SHA-256 digest of the fingerprint contents given below:</t>

<figure><artwork><![CDATA[
RsaSha256FingerprintContents ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. The first byte of the modulus MUST NOT be zero.</t>
  <t>The corresponding public exponent e is assumed to be 65537 as recommended in <xref target="RFC4871"></xref> . Very large exponents can be a DoS vector <xref target="LARGE-RSA-EXPONENTS"></xref> and 65537 is the largest Fermat prime, which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"></xref> .</t>
  <t>Implementations MUST reject moduli smaller than 128 bytes (1017 bits) or greater than 512 bytes (4096 bits.) Large moduli slow down signature verification which can be a denial-of-service vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"></xref> . OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES"></xref> .</t>
</list></t>

</section>
<section anchor="rsa-sha-256-condition-type-maxfulfillmentlength" title="MaxFulfillmentLength">

<t>The maxFulfillmentLength is the length in bytes of the modulus multiplied by 2.</t>

</section>
<section anchor="rsa-sha-256-condition-type-fulfillment" title="Fulfillment Format">

<figure><artwork><![CDATA[
RsaSha256FulfillmentPayload ::= SEQUENCE {
  modulus OCTET STRING (SIZE(128..512)),
  signature OCTET STRING (SIZE(128..512))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='modulus'>
  is an octet string representing the RSA public modulus in big-endian byte order. See <xref target="rsa-sha-256-condition-type-condition"></xref></t>
  <t hangText='signature'>
  is an octet string representing the RSA signature. It MUST be encoded in big-endian byte order with the exact same number of octets as the modulus, even if this means adding leading zeros. This ensures that the fulfillment size is constant and known ahead of time. Note that the field is still binary encoded with a length prefix for consistency.</t>
  <t>Implementations MUST verify that the signature and modulus consist of the same number of octets and that the signature is numerically less than the modulus.</t>
</list></t>

<t>The message to be signed is provided separately. If no message is provided, the message is assumed to be an octet string of length zero.</t>

</section>
<section anchor="rsa-sha-256-condition-type-implementation" title="Implementation">
<t>The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"></xref> . In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of security <xref target="NIST-KEYMANAGEMENT"></xref> (p. 64), about the same level as SHA-256.</t>

</section>
<section anchor="rsa-sha-256-condition-type-validating" title="Validating">

<t>An RSA-SHA-256 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the RSA public key derived using a modulus of F.modulus and an exponent of 65537.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="rsa-sha-256-example" title="Example">

<t>TODO</t>

</section>
</section>
<section anchor="ed25519-condition-type" title="ED25519">
<t>ED25519 is assigned the type ID 4. It relies on the SHA-512 digest algorithm and the ED25519 signature scheme as the condition fingerprint is not a digest.</t>

<t>The exact algorithm and encodings used for the public key and signature are defined in <xref target="I-D.irtf-cfrg-eddsa"></xref> as Ed25519. SHA-512 is used as the hashing function.</t>

<section anchor="ed25519-condition-type-condition" title="Condition Format">

<t>The fingerprint of an ED25519 condition is the 32 byte Ed25519 public key. Since the public key is already very small, we do not hash it.</t>

</section>
<section anchor="ed25519-condition-type-fulfillment" title="Fulfillment">

<figure><artwork><![CDATA[
Ed25519FulfillmentPayload ::= SEQUENCE {
  publicKey OCTET STRING (SIZE(32)),
  signature OCTET STRING (SIZE(64))
}
]]></artwork></figure>

<t><list style="hanging">
  <t hangText='publicKey'>
  is an octet string containing the Ed25519 public key.</t>
  <t hangText='signature'>
  is an octet string containing the Ed25519 signature.</t>
</list></t>

</section>
<section anchor="ed25519-sha-256-condition-type-validating" title="Validating">

<t>An ED25519 fulfillment is valid iff :</t>

<t><list style="numbers">
  <t>F.signature is valid for the message M, given the ED25519 public key F.publicKey.</t>
  <t>D is equal to C.</t>
</list></t>

</section>
<section anchor="example" title="Example">

<t>TODO</t>

</section>
</section>
</section>


  </middle>

  <back>

    <references title='Normative References'>

&RFC3447;
&RFC4648;
&I-D.draft-irtf-cfrg-eddsa-04;
<reference anchor="itu.X680.2015" target="https://www.itu.int/rec/T-REC-X.680-201508-I/">
  <front>
    <title>Information technology – Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="itu.X696.2015" target="http://handle.itu.int/11.1002/1000/12487">
  <front>
    <title>Information technology – ASN.1 encoding rules: Specification of Octet Encoding Rules (OER)</title>
    <author >
      <organization>International Telecommunications Union</organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>

&RFC2119;
&RFC3110;
&RFC4871;
<reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
  <front>
    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
    <author fullname="Adam Langley">
      <organization></organization>
    </author>
    <date year="2012" month="March" day="17"/>
  </front>
</reference>
<reference anchor="USING-RSA-EXPONENT-OF-65537" target="https://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
  <front>
    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu">
      <organization></organization>
    </author>
    <date year="2014" month="November" day="18"/>
  </front>
</reference>
<reference anchor="KEYLENGTH-RECOMMENDATION" target="https://www.keylength.com/en/compare/">
  <front>
    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
    <author fullname="Damien Giry">
      <organization></organization>
    </author>
    <date year="2015" month="September" day="17"/>
  </front>
</reference>
<reference anchor="NIST-KEYMANAGEMENT" target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
  <front>
    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
    <author fullname="Elaine Barker">
      <organization></organization>
    </author>
    <author fullname="William Barker">
      <organization></organization>
    </author>
    <author fullname="William Burr">
      <organization></organization>
    </author>
    <author fullname="William Polk">
      <organization></organization>
    </author>
    <author fullname="Miles Smid">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>
<reference anchor="OPENSSL-X509-CERT-EXAMPLES" target="http://fm4dd.com/openssl/certexamples.htm">
  <front>
    <title>OpenSSL - X509 certificate examples for testing and verification</title>
    <author fullname="FM4DD">
      <organization></organization>
    </author>
    <date year="2012" month="July"/>
  </front>
</reference>


    </references>


<section anchor="security-considerations" title="Security Considerations">

<t>This section to be expanded in a later draft. <!-- TODO --></t>

</section>
<section anchor="test-values" title="Test Values">

<t>This section to be expanded in a later draft.  <!-- TODO --> For now, see the test cases for the reference implementation: <eref target="https://github.com/interledger/five-bells-condition/tree/master/test">https://github.com/interledger/five-bells-condition/tree/master/test</eref></t>

</section>
<section anchor="appendix-c" title="ASN.1 Module">

<figure><artwork><![CDATA[
--<ASN1.PDU CryptoConditions.Condition, CryptoConditions.Fulfillment>--

CryptoConditions
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/**
* CONTAINERS
*/

Condition ::= SEQUENCE {
    type ConditionType,
    fingerprint OCTET STRING,
    maxFulfillmentLength INTEGER (0..MAX),
    subtypes OCTET STRING
}

Fulfillment ::= SEQUENCE {
    type ConditionType,
    payload OCTET STRING
}

ConditionType ::= INTEGER {
    preimageSha256(0),
    prefixSha256(1),
    thresholdSha256(2),
    rsaSha256(3),
    ed25519(4)
} (0..255)
    
/**
* FULFILLMENT PAYLOADS
*/

-- For preimage conditions, the payload equals the preimage

PrefixSha256FulfillmentPayload ::= SEQUENCE {
    prefix OCTET STRING,
    subfulfillment Fulfillment
}

ThresholdSha256FulfillmentPayload ::= SEQUENCE {
    threshold INTEGER (1..255),
    subfulfillments SEQUENCE OF Fulfillment,
    subconditions SEQUENCE OF Condition
}

RsaSha256FulfillmentPayload ::= SEQUENCE {
    modulus OCTET STRING (SIZE(128..512)),
    signature OCTET STRING (SIZE(128..512))
}

Ed25519FulfillmentPayload ::= SEQUENCE {
    publicKey OCTET STRING (SIZE(32)),
    signature OCTET STRING (SIZE(64))
}

/**
* FINGERPRINTS
*/

-- SHA-256 hash of the fingerprint contents
Sha256Fingerprint ::= OCTET STRING (SIZE(32)) -- digest

-- 32-byte Ed25519 public key
Ed25519Fingerprint ::= OCTET STRING (SIZE(32)) -- publicKey

/**
* FINGERPRINT CONTENTS
*
* The content that will be hashed to arrive at the fingerprint.
*/

-- The preimage type hashes the raw contents of the preimage

PrefixSha256FingerprintContents ::= SEQUENCE {
    prefix OCTET STRING,
    condition Condition
}

ThresholdSha256FingerprintContents ::= SEQUENCE {
    threshold INTEGER (1..255),
    subconditions SEQUENCE OF Condition
}

RsaSha256FingerprintContents ::= SEQUENCE {
    modulus OCTET STRING (SIZE(128..512))
}

/**
* EXAMPLES
*/

exampleCondition Condition ::=
{
    type preimageSha256,
    fingerprint '
    E3B0C442 98FC1C14 9AFBF4C8 996FB924 27AE41E4 649B934C A495991B 7852B855
    'H,
    maxFulfillmentLength 2,
    subtypes ''B
}

exampleFulfillment Fulfillment ::=
{
    type preimageSha256,
    payload '00'H
}

exampleRsaSha256FulfillmentPayload RsaSha256FulfillmentPayload ::=
{
    modulus '
    B30E7A93 8783BABF 836850FF 49E14F87 E3F92D5C 46E33FEC A3E4F0B2 2358580B
    11765995 F4B8EEA7 FB4712C2 E1E316F7 F775A953 D232216A 169D9A64 DDC00712
    0A400B37 F2AFC077 B62FE304 DE74DE6A 119EC407 6B529C4F 6096B0BA AD4F533D
    F0173B9B 822FD85D 65FA4BEF A92D8F52 4F69CBCA 0136BD80 D095C169 AEC0E095
    'H,
    signature '
    48E8945E FE007556 D5BF4D5F 249E4808 F7307E29 511D3262 DAEF61D8 8098F9AA
    4A8BC062 3A8C9757 38F65D6B F459D543 F289D73C BC7AF4EA 3A33FBF3 EC444044
    7911D722 94091E56 1833628E 49A772ED 608DE6C4 4595A91E 3E17D6CF 5EC3B252
    8D63D2AD D6463989 B12EEC57 7DF64709 60DF6832 A9D84C36 0D1C217A D64C8625
    BDB594FB 0ADA086C DECBBDE5 80D424BF 9746D2F0 C312826D BBB00AD6 8B52C4CB
    7D47156B A35E3A98 1C973863 792CC80D 04A18021 0A524158 65B64B3A 61774B1D
    3975D78A 98B0821E E55CA0F8 6305D425 29E10EB0 15CEFD40 2FB59B2A BB8DEEE5
    2A6F2447 D2284603 D219CD4E 8CF9CFFD D5498889 C3780B59 DD6A57EF 7D732620
    'H
}

exampleEd25519FulfillmentPayload Ed25519FulfillmentPayload ::=
{
    publicKey '
    EC172B93 AD5E563B F4932C70 E1245034 C35467EF 2EFD4D64 EBF81968 3467E2BF
    'H,
    signature '
    B62291FA D9432F8F 298B9C4A 4895DBE2 93F6FFDA 1A68DADF 0CCDEF5F 47A0C721
    2A5FEA3C DA97A3F4 C03EA9F2 E8AC1CEC 86A51D45 2127ABDB A09D1B6F 331C070A
    'H
}

END
]]></artwork></figure>

</section>
<section anchor="appendix-e" title="IANA Considerations">

<section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">

<t>The following initial entries should be added to the Crypto-Condition Type registry to be created and maintained at (the suggested URI)
<eref target="http://www.iana.org/assignments/crypto-condition-types">http://www.iana.org/assignments/crypto-condition-types</eref>:</t>

<t>The following types are registered:</t>

<texttable title="Crypto-Condition Types" anchor="crypto-condition-types-table">
      <ttcol align='left'>Type ID</ttcol>
      <ttcol align='left'>Type Name</ttcol>
      <c>0</c>
      <c>PREIMAGE-SHA-256</c>
      <c>1</c>
      <c>PREFIX-SHA-256</c>
      <c>2</c>
      <c>THRESHOLD-SHA-256</c>
      <c>3</c>
      <c>RSA-SHA-256</c>
      <c>4</c>
      <c>ED25519</c>
</texttable>

</section>
</section>
<section anchor="appendix-f" title="String Encoding">

<t>Implementations MAY support one or both string encoding formats which encode conditions and fulfillments as either URIs or JSON objects. The binary encoding is considered the canonical encoding.</t>

<t>The following string encoding types are defined:</t>

<t><list style="hanging">
  <t hangText='BASE10'>
  Variable-length integer encoded as a base-10 (decimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows.</t>
  <t hangText='BASE16'>
  Variable-length integer encoded as a base-16 (hexadecimal) number. Implementations MUST reject encoded values that are too large for them to parse. Implementations MUST be tested for overflows. Encodings may have an odd number of characters as the encoding excludes leading zeros.</t>
  <t hangText='BASE64URL'>
  Base64-URL encoding. See <xref target="RFC4648"></xref>, Section 5.</t>
</list></t>

<section anchor="string-condition-format" title="Condition URI Format">

<t>Conditions are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cc:" BASE10(type) ":" BASE64URL(fingerprint) ":" 
BASE10(maxFulfillmentLength) ":" BASE16(subtypes) 
]]></artwork></figure>

<t>For simple types the subtypes field (and ":" prefix) may be excluded.</t>

<section anchor="example-condition" title="Example Condition">

<t>An example condition:</t>

<figure><artwork><![CDATA[
0x00000000 00 00 01 03 20 7F 83 B1 65 7F F1 FC 53 B9 2D C1 ........e...S.-.
0x00000010 81 48 A1 D6 5D FC 2D 4B 1F A3 D6 77 28 4A DD D2 .H..].-K...w(J..
0x00000020 00 12 6D 90 69 03 FF FF FF                      ..m.i....

cc:0:dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA:66
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cc</spanx></c>
      <c>Constant. Indicates this is a condition.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>fingerprint</c>
      <c><spanx style="verb">dB-8fb14MdO75Brp_Pvh4d7ganckilrRl13RS_UmrXA</spanx></c>
      <c>The hash of the fulfillment for this condition.</c>
      <c>maxFulfillmentLength</c>
      <c><spanx style="verb">66</spanx></c>
      <c>The fulfillment payload is 66 bytes long, before being BASE64URL-encoded.</c>
      <c>subtypes</c>
      <c>``</c>
      <c>Absent</c>
</texttable>

</section>
<section anchor="string-fulfillment-format" title="Fulfillment URI Format">

<t>Fulfillments are ASCII encoded as:</t>

<figure><artwork><![CDATA[
"cf:" BASE10(type) ":" BASE64URL(payload)
]]></artwork></figure>

</section>
<section anchor="example-fulfillment" title="Example Fulfillment">

<t>The following is an example fulfillment in string format, for the <xref target="example-condition">example condition</xref>:</t>

<figure><artwork><![CDATA[
cf:0:VGhlIG9ubHkgYmFzaXMgZm9yIGdvb2QgU29jaWV0eSBpcyB1bmxpbWl0ZWQgY3JlZGl0LuKAlE9zY2FyIFdpbGRl
]]></artwork></figure>

<t>The example has the following attributes:</t>

<texttable>
      <ttcol align='left'>Field</ttcol>
      <ttcol align='left'>Value</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>preface</c>
      <c><spanx style="verb">cf</spanx></c>
      <c>Constant. Indicates this is a fulfillment.</c>
      <c>type</c>
      <c><spanx style="verb">0</spanx></c>
      <c>Type 0 is [PREIMAGE-SHA-256][].</c>
      <c>payload</c>
      <c><spanx style="verb">VGhlIG...pbGRl</spanx></c>
      <c>The BASE64URL-encoded SHA-256 preimage of the condition, since this is a PREIMAGE-SHA-256 type fulfillment. In this case, it is an arbitrary string.</c>
</texttable>

</section>
</section>
</section>


  </back>

<!-- ##markdown-source:
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
FqdeZIMJ3prsdZQ7Ka26fgLL/T/APMWItqkAAA==

-->

</rfc>

